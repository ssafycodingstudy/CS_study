## 트랜잭션 

데이터베이스의 상태를 변화시키기 해서 수행하는 작업의 단위

상태를 변화시킨다는 것 → **SQL 질의어를 통해 DB에 접근하는 것**

- SELECT
- INSERT
- DELETE
- UPDATE

#### 트랜잭션의 특징

- 원자성

트랜잭션이 데이터베이스에 모두 반영되던가, 아니면 전혀 반영되지 않아야 한다는 것

- 일관성

트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다는 것

- 독립성

독립성은 둘 이상의 트랜잭션이 동시에 실행되고 있을 경우 어떤 하나의 트랜잭션이라도, 다른 트랜잭션의 연산에 끼어들 수 없다는 점

- 지속성

트랜잭션이 성공적으로 완료됬을 경우, 결과는 영구적으로 반영되어야 한다는 점

#### 트랜잭션의 Commit, Rollback 연산

- commit

하나의 트랜잭션이 성공적으로 끝났고, 데이터베이스가 일관성있는 상태에 있을 때, 하나의 트랜잭션이 끝났다라는 것을 의미

- rollback

트랜잭션 처리가 비정상적으로 종료되어 트랜잭션의 원자성이 깨진경우, 트랜잭션을 처음부터 다시 시작하거나, 트랜잭션의 부분적으로만 연산된 결과를 다시 취소함

트랜잭션 관리를 위한 DBMS의 전략

#### DBMS의 구조

https://d2.naver.com/content/images/2015/06/helloworld-407507-1.png

UNDO

필요한 이유 : 수정된 Page들이 **Buffer 교체 알고리즘에 따라서 디스크에 출력**될 수 있음. Buffer 교체는 **transaction과는 무관하게 buffer의 상태에 따라서, 결정됨**. 이로 인해, 정상적으로 종료되지 않은 transaction이 변경한 page들은 원상 복구 되어야 하는데, 이 복구를 undo라고 함.

- STEAL: 수정된 페이지를 언제든지 디스크에 쓸 수 있는 정책
- ¬STEAL: 수정된 페이지들을 최소한 트랜잭션 종료 시점(EOT, End of Transaction)까지는 버퍼에 유지하는 정책

STEAL 정책은 수정된 페이지가 어떠한 시점에도 디스크에 써질 수 있기 때문에 필연적으로 UNDO 로깅과 복구를 수반하는데, 거의 모든 DBMS가 채택하는 버퍼 관리 정책

REDO

이미 commit한 transaction의 수정을 재반영하는 복구 작업

- FORCE: 수정했던 모든 페이지를 트랜잭션 커밋 시점에 디스크에 반영하는 정책
- ¬FORCE: 수정했던 페이지를 트랜잭션 커밋 시점에 디스크에 반영하지 않는 정책



DBMS는 버퍼 관리 정책으로 STEAL과 ¬FORCE 정책을 채택하고 있어, 이로 인해서 UNDO 복구와 REDO 복구가 모두 필요





## 트랜잭션 격리수준

동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 고립되어 있는가



#### 격리수준

- READ UNCOMMITTED
- READ COMMITTED
- REPEATABLE READ
- SERIALIZABLE

아래로 내려갈수록 고립도가 높아지고 성능이 떨어짐



#### READ UNCOMMITTED

어떤 트랜잭션의 변경내용이 Commit이나 Rollback과 상관없이 다른 트랜잭션에서 보여짐

문제점

ex) 

1. a트랜잭션이 1번사원이 나이를 27 = > 28로 변경

커밋하지않음

b트랜잭션에서 1번사원을 조회

28살로 조회됨

-더티리드 현상 발생

a트랜잭션에서 문제가 발생해 Rollback함

b트랜잭션은 28살로 생각하고 로직 수행

-> 데이터 정합성에 문제가 많으므로 RDBMS 표준에서는 격리수준으로 인정하지 않음

#### READ COMMITTED

어떤 트랜잭션의 변경 내용이 COMMIT 되어야만 다른 트랜잭션에서 조회 가능

문제점

1. B 트랜잭션에서 10번 사원의 나이를 조회
2. 27살이 조회됨
3. A 트랜잭션에서 10번 사원의 나이를 27살에서 28살로 바꾸고 `커밋`
4. B 트랜잭션에서 10번 사원의 나이를 다시 조회(변경되지 않은 이름이 조회됨)
5. 28살이 조회됨

정합성이 해결된것처럼 보이나 하나의 트랜잭션 내에서 똑같은 SELECT을 수행했을 경우 항상 같은 결과를 반환해야 한다는 REPEATABLE READ 정합성에 어긋남

#### REPEATABLE READ

트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있는 격리수준

이 격리수준에서는 NON-REPETABLE READ 부정합이 발생하지 않음

문제점

###### update 부정합

```
START TRANSACTION; -- transaction id : 1
SELECT * FROM Member WHERE name='junyoung';

    START TRANSACTION; -- transaction id : 2
    SELECT * FROM Member WHERE name = 'junyoung';
    UPDATE Member SET name = 'joont' WHERE name = 'junyoung';
    COMMIT;

UPDATE Member SET name = 'zion.t' WHERE name = 'junyoung'; -- 0 row(s) affected
COMMIT;
```

이 상황에서 최종 결과는 `name = joont`가 된다



1. 2번 트랜잭션에서 `name = joont`로 변경하고 COMMIT을 하면 `name = junyoung`의 내용을 언두로그에 남겨놔야 함

2. UPDATE의 경우 변경을 수행할 로우에 대해 잠금이 필요

3.  1번 트랜잭션이 바라보고 있는 `name = junyoung` 의 경우 레코드 데이터가 아닌 언두영역의 데이터이고,
   언두영역에 있는 데이터에 대해서는 쓰기 잠금을 걸 수가 없음
4. `me = junyoung`인 레코드는 존재하지 않으므로,`0 row(s) affected`가 출력되고, 아무 변경도 일어나지 않게됨

-> 간단하게 말해 DML 구문은 멀티버전을 관리하지 않는다

##### Phantom READ

한 트랜잭션 내에서 같은 쿼리를 두 번 실행했는데, 첫 번째 쿼리에서 없던 유령(Phantom) 레코드가 두 번째 쿼리에서 나타나는 현상

REPETABLE READ 이하에서만 발생하고(SERIALIZABLE은 발생하지 않음), INSERT에 대해서만 발생한다.
아래와 같은 상황에서 재현될 수 있음

```
START TRANSACTION; -- transaction id : 1 
SELECT * FROM Member; -- 0건 조회

    START TRANSACTION; -- transaction id : 2
    INSERT INTO MEMBER VALUES(1,'joont',28);
    COMMIT;

SELECT * FROM Member; -- 여전히 0건 조회 
UPDATE Member SET name = 'zion.t' WHERE id = 1; -- 1 row(s) affected
SELECT * FROM Member; -- 1건 조회 
COMMIT;
```





##### SERIALIZABLE

격리수준이 SERIALIZABLE일 경우 읽기 작업에도 `공유 잠금`을 설정하게 되고, 이러면 동시에 다른 트랜잭션에서 이 레코드를 변경하지 못하게 됨

이러한 특성 때문에 동시처리 능력이 다른 격리수준보다 떨어지고, 성능저하가 발생.

[참고]

https://mommoo.tistory.com/62

https://d2.naver.com/helloworld/407507

https://joont92.github.io/db/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80-isolation-level/ 