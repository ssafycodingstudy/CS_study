# 14주차 CS 발표

## 트랜잭션 격리 수준 (Transaction Isolation Level)

### 개념

트랜잭션 격리수준이란 동시에 여러 트랜잭션이 처리 될 때, **트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 것**</br>
즉, 특정 트랜잭션이 다른 트랜잭션에 변경한 데이터를 볼 수 있도록 허용할지 말지를 결정함

데이터베이스는 ACID 특징과 같이 트랜잭션이 독립적인 수행을 하도록 Locking 을 통해, 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하도록 막는 것이 필요함

하지만 무조건 Locking으로 동시에 수행되는 수많은 트랜잭션들을 순서대로 처리하는 방식으로 구현하게 되면 데이터베이스의 성능은 떨어지게 됨. 하지만, 성능을 높이기 위해 Locking의 범위를 줄인다면, 잘못된 값이 처리될 문제가 발생할 수 있음

**따라서 최대한 효율적인 Locking 방법이 필요**

- Lock
  - 트랜잭션 처리의 순차성을 보장하기 위한 방법 (동시성 제어)
  - DBMS 마다 Lock을 구현하는 방식이 다르기 때문에 DBMS를 효과적으로 이용하기 위해서 해당 DB의 Lock에 대한 이해가 요구됨
    - 공유(shared) lock : **데이터를 읽을 때** 사용되는 lock
      - 공유 락은 공유 락끼리 동시에 접근이 가능함
      - 하지만, 공유 락이 설정된 데이터에 배타 락을 사용할 수 없음
    - 배타(exclusive) lock : **데이터를 변경하고자 할 때** 사용되며, 트랜잭션이 완료될 때까지 유지됨
      - Lock이 해제될 때까지 다른 트랜잭션(읽기 포함)은 해당 리소스에 접근할 수 없음
      - 해당 Lock은 트랜잭션이 수행되고 있는 데이터에 대해서는 접근하여 함께 Lock을 설정할 수 없음



### Isolation Level 종류

격리 수준은 4개로 구분

- Read Uncommitted (레벨 0)
- Read Committed (레벨 1)
- Repeatable Read (레벨 2)
- Serializable (레벨 3)

> 레벨이 높아질수록 동시성 접근 제어의 수준이 강해지며, 동시 처리 성능은 낮아짐 
>
> 접근 제어를 강하게 수행한다는 것은 트랜잭션이 끝나기 전까지 해당 데이터를 잠그고 다른 트랜잭션에서 참조하지 못하게 하는 것이기 때문



#### Read Uncommitted

커밋되지 않은 데이터에 접근이 가능한 수준으로, N개의 트랜잭션이 하나의 공유 데이터에 접근해도 전혀 보호되지 않음

<img src="https://blog.kakaocdn.net/dn/u1BKr/btqEcois9nW/QgZsUlGnEHWoNHakmJ5g21/img.png" alt="img" style="zoom:50%;" />

```
1. 트랜잭션 1을 시작함
2. 트랜잭션 2를 시작함
3. 트랜잭션 1이 ID=1, VAL='MIN'인 데이터의 VAL을 'KIM'으로 변경함
4. 트랜잭션 2가 ID=1을 조회함. VAL='KIM'이 조회됨
5. 트랜잭션 1, 2가 종료됨 
```

이 수준에서만 볼 수 있는 문제는 `Dirty Read`가 있음

> **Dirty Read**
>
> 어떤 트랜잭션에서 아직 실행이 끝나지 않은 다른 트랜잭션에 의한 변경사항을 보게 되는 경우
>
> 커밋되지 않은 수정중인 데이터를 다른 트랜잭션에서 **읽을 수 있도록 허용할 때** 발생하는 현상
>
> ```
> Update 반영 전에 읽는 오류
>   - 순서 5에 오류가 생겨 롤백이 되었다고 가정. `ID=1` 은 다시 `MIN`이 됨
>   - 그러나 롤백 전인 순서 4번은 여전히 `VAL = 'KIM'` 으로 인식할 것
> Insert 반영 전에 읽는 오류
>   - 트랜잭션 1이 특정 데이터는 Insert함
>   - 트랜잭션 2가 그 데이터를 읽고 로직을 수행함
>   - 트랜잭션 1 수행 중 오류가 생겨 롤백됨. Insert한 데이터가 삭제됨
>   - 그러나 트랜잭션 2는 이미 로직을 수행한 상태
> ```



#### Read Committed

커밋된 데이터만 조회할 수 있어 `Dirty Read` 는 발생하지 않음

<img src="https://blog.kakaocdn.net/dn/oXqMg/btqEeqFWXsr/d5WDuP5MjIawLjNQen8Nb1/img.png" alt="img" style="zoom:50%;" />



```
1. 트랜잭션 1을 시작함
2. 트랜잭션 1이 ID = 1인 데이터의 VALUE를 KIM으로 변경
3. 트랜잭션 2를 시작함
4. 트랜잭션 2가 ID =1인 데이터를 조회함. MIN이 검색됨
5. 트랜잭션 1이 커밋을 하고 종료함
6. 트랜잭션 2가 ID=1인 데이터를 조회함. KIM이 검색됨
7. 트랜잭션 2가 커밋을하고 종료함
```

커밋된 데이터만을 읽어오기 때문에 `Read Uncommitted` 에서 롤백되는 경우 발생하는 문제는 생기지 않음

이 격리 수준 이하에서는 `Non-Repeatable Read` 문제가 발생함

> **Non-Repeatable Read**
>
> 하나의 트랜잭션에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션 값을 **수정 또는 삭제** 하면서 두 쿼리의 결과가 상이하게 나타나는 **일관성이 깨진 현상**
>
> 한 트랜잭션에서 똑같은 Select를 수행했을 때 항상 같은 결과를 반환해야한다는 Repeatable Read 정합성에 어긋남
>
> ```
> 위의 그림에서 트랜잭션 2의 첫번째 조회엔 MIN이, 두번째 조회엔 KIM이 검색되고 있음
> ```



#### Repeatable Read

트랜잭션이 시작되고 종료되기 전까지 한 번 조회한 값은 계속 같은 값이 조회되는 격리 수준

트랜잭션 시작 전에 커밋된 내용에 한해서만 조회됨

데이터를 변경하려고 하면 `UNDO` 영역에 백업해두고 실제 레코드를 변경하게 됨

이 격리 수준에서는 `Non-Repeatalbe Read` 는 발생하지 않음

<img src="https://blog.kakaocdn.net/dn/mMt8U/btq5JCNMucD/QwCb2y8vL4RgNQNeXyX6s0/img.png" alt="img" style="zoom:50%;" />

```
1. 트랜잭션 1을 시작함
2. 트랜잭션 1이 ID = 1인 데이터를 조회함
3. 트랜잭션 2가 시작됨
4. 트랜잭션 2가 ID = 1인 데이터를 KIM으로 변경함
5. 트랜잭션 1이 ID =1인 데이터를 조회함. 트랜잭션 2의 변경 내역이 보이지 않음
6. 트랜잭션 2가 ID =2인 데이터를 삽입 후 commit 하여 트랜잭션을 종료함
7. 트랜잭션 1이 ID =2인 데이터를 조회함. 데이터가 정상적으로 확인됨
8. 트랜잭션 1이 종료됨
```

이 격리 수준에서는 **Update**  한 데이터에 대해서는 정합성을 보장하지만, **Insert/Delete** 는 보장되지 않음

이 때문에 이 격리 수준 이하에서는 `Phantom Read` 문제가 발생함

> **Phantom Read**
>
> 마치 유령을 보는 것처럼 있던 데이터가 사라지거나 없던 데이터가 생기는 현상을 말함
>
> 한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽었을 때, 첫번째 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상
>
> 트랜잭션 도중 새로운 레코드 **삽입** 을 허용하기 때문에 나타남
>
> ```
> 바로 위 예제의 순서 7에서 트랜잭션 1이 ID=2인 데이터를 조회하고 있음
> 
> ID = 2는 트랜잭션 1이 시작하던 시점에선 테이블에 없던 데이터임
> 
> 만약, 순서 8에서 트랜잭션 2가 비정상 종료되어 롤백되었다고 가정한다면 (2,'KIM') 데이터는 삽입되지 않으며
> 
> 트랜잭션 1은 ID=2인 데이터를 읽을 수 없음
> ```



#### Serializable

트랜잭션이 특정 테이블을 읽으면 다른 트랜잭션은 그 테이블의 데이터를 추가/변경/삭제할 수 없음

가장 강력한 격리 수준이며 데이터 정합성을 가장 잘 보장함

그러나 동시 처리 성능이 가장 떨어짐

이 격리 수준에서는 위에서 언급했던 `Dirty Read`, `Non-Repeatable Read`, `Phantom Read` 와 같은 정합성 문제가 전혀 발생하지 않음



### 선택 시 고려사항

Isolation Level에 대한 조정은 **동시성** 과 **데이터 무결성** 에 연관되어 있음

`동시성을 증가시키면 데이터 무결성에 문제가 발생하고, 데이터 무결성을 유지하면 동시성이 떨어지게 됨`

레벨을 높에 조정할 수록 발생하는 비용이 증가함

> 무결성(Integrity) : 데이터의 정확성, 일관성, 유효성이 유지되는 것
>
> - 개체 무결성 : 모든 테이블이 기본키로 선택된 필드를 가져야 함(기본키를 가져야 함). 고유한 값, Null 허용하지 않음
> - 참조 무결성 : 참조 관계에 있는 두 테이브르이 데이터가 항상 일관된 값을 갖도록 유지. 참조 대상이 존재하지 않는 외래키를 허용하지 않음
>   - Restricted : 레코드를 참조하고 있는 개체가 있다면, 변경 또는 삭제 연산을 취소
>   - Cascade : 레코드를 참조하고 있는 개체도 변경 또는 삭제
>   - Set Null : 레코드를 참조하고 있는 개체의 값을 Null로 설정
> - 도메인 무결성 : 테이블에 존재하는 필드의 무결성 보장. 필드의 타입, null값의 허용 등 사항을 정의하고 올바른 데이터가 입력되었는지 확인하는 것
> - 무결성 규칙 : 데이터의 무결성을 지키기 위한 모든 제약 사항을 말함. 데이터베이스 전체에 공통적으로 적용되는 규칙



일반적인 온라인서비스에서는 Read Committed나 Repeatable Read 중 하나를 사용함 (Oracle = Read Committed, MySQL=Repeatable Read)



---

[참고 1] : <https://dar0m.tistory.com/225>

[참고 2] : <https://private-space.tistory.com/97>
