### 트랜잭션의 격리 수준이란?

- 동시에 여러 트랜잭션이 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회한 데이터를 볼 수 있도록 허용 여부를 결정하는 것



### 필요성

- 데이터베이스는 ACID 같이 트랜잭션이 원자적이면서도 독립적인 수행을 하도록 한다.
- 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하게 막는 Locking 개념이 등장
- 무조건적인 Locking으로 동시에 수행되는 많은 트랜잭션들을 순서대로 처리할 시에 DB성능이 떨어지게 됨
- 응답성을 높이기 위해 Locking 범위를 줄인다면 잘못된 값이 처리될 여지가 있음
- 효율적인 Locking 방법이 필요



### 격리 수준의 종류

- READ UNCOMMITTED(Level 0)
  - 각 트랜잭션의 변경 내용이 COMMIT/ROLLBACK 여부 상관 없이 다른 트랜잭션에서 값 읽기 가능
  - 정합성에 문제가 많은 격리 수준이기 때문에 사용하지 않는 것 권장
- READ COMMITTED(Level 1)
  - 대부분 RDB에서 기본적으로 사용되고 있는 격리 수준
  - Dirty Read와 같은 현상 발생 안함
  - 실제 테이블 값을 가져오는 것이 아니라, Undo 영역의 백업된 레코드에서 값을 가져옴
  - 하나의 트랜잭션에서 똑같은 SELECT 쿼리 실행 시, 항상 같은 결과를 가져와야하는 REPEATABLE READ의 정합성에 어긋남
- REPEATABLE READ(Level 2)
  - MySQL경우 트랜잭션마다 트랜잭션 ID를 부여해 해당 ID보다 작은 트랜잭션 번호에서 변경한 것만 읽게 함
  - Undo 공간에 백업해두고 실제 레코드 값을 변경
  - 백업된 데이터는 불필요하다고 판단하는 시점에 주기적으로 삭제
  - Undo 백업된 레코드가 많아지면 MySQL 서버의 처리 성능이 떨어질 수 있음
  - 이러한 변경 방식을 MVCC(Multi Version Concurrency Control) 라고 부름
- SERIALIZABLE(Level 3)
  - 가장 단순한 격리 수준이면서 가장 엄격함
  - 성능 측면에서는 동시 처리 성능이 가장 낮음
  - SERIALIZABLE에서는 PHANTOM READ가 발생하지 않음. 하지만 DB에서는 거의 사용 안함



### 각종 이상 현상

- Dirty Read
  - 트랜잭션이 완료되지 않았는데, 다른 트랜잭션에서 볼수 있게 되는 현상
- Non-Repeatable Read
  - 한 트랜잭션에서 같은 쿼리를 두 번 수행할 때, 두 쿼리의 결과가 상이하게 나타나는 비일관성 현상
  - 한 트랜잭션이 수행 중일 때 다른 트랜잭션이 값을 수정 또는 삭제함으로써 발생
- Phantom Read
  - 한 트랜잭션에서 같은 쿼리를 두 번 수행할 때, 첫 번째 쿼리에서 없던 레코드가 두 번째 쿼리에서 나타나는 현상
  - 한 트랜잭션이 수행 중일 때 다른 트랜잭션이 새로운 레코드를 INSERT 함으로써 나타남

