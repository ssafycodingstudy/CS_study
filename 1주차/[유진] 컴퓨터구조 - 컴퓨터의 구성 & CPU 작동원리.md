# 컴퓨터의 구성

메모리, 입력과 출력, CPU 3가지로 나눌 수 있다.

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%89%E1%85%A5%E1%86%BC%20e0da915beee94222bf08cb6f9d89301c/Untitled.png)

---

## Memory

- 조작할 비트들을 저장할 장소
- 기본 단위 : 바이트(Byte)
- 주기억 장치 / 보조 기억 장치 / 캐시 메모리 등으로 구성

### 주기억 장치

- CPU와 직접 통신 가능하며, CPU가 현재 사용하는 정보 저장
- RAM과 ROM으로 구성되어 있음
    - RAM은 읽고 쓰기가 가능하며, 변경될 가능성이 있는 프로그램이나 데이터 저장
    - ROM은 읽기만 가능하며, 불변 상수, 표 등을 저장
    

### 보조 기억 장치

- 주기억 장치가 저장하고 있는 것을 제외한 모든 정보 저장
- 대표적인 보조 기억 장치는 HDD와 SDD
    - **HDD**는 물리적인 디스크를 고속으로 회전시켜 데이터를 저장하는 장치
    - 충격에 약하며, 소음 발생
    - **SDD**는 반도체 기반의 정보를 저장하는 기억장치
    - 전기적으로 데이터 저장하여 HDD에 비해 속도가 월등히 빠르고, 소음 발생 X
    - 전력소모 적고, 경량화, 소형화 가능하지만 가격이 다소 높음
    

### 캐시 메모리

- CPU의 처리속도와 주기억장치의 접근 속도 차이로 인한 병목 현상을 완화하기 위해 사용되는 메모리
- 메모리와 CPU 사이에 위치

---

## 입력과 출력(I/O)

- 컴퓨터와 사용자 사이의 데이터를 교환할 수 있는 장치
- 입력 장치 : 자료를 컴퓨터가 인식할 수 있는 형태로 변환시켜 주기억장치로 읽어 들이는 장치
    - 키보드, 마우스
- 출력 장치 : 컴퓨터에서 처리된 내용을 사용자가 인식할 수 잇는 형태로 바꾸어 표시하는 장치
    - 프린터, 모니터
- 이전에는 버스를 메모리와 따로 사용했지만 현재는 메모리가 커짐에 따라 메모리와 공유

---

## CPU

각종 연산을 수행하고 기억장치에 기억되어 있는 명령어들을 수행하는 컴퓨터 시스템을 이루는 핵심 부품

내부 구성 요소 = ALU + 제어 장치 + 레지스터

### **ALU(arithmetic login unit, 산술 논리 장치)**

- CPU의 핵심 부품
- 레지스터에 저장된 데이터를 이용해 산술 연산 수행
- 산술 계산, 불리언 대수 및 기타 연산을 수행하는 방법을 알고 있음
- 피연산자: 수를 표현하는 코드
- 연산 코드 : ALU가 어떤 연산자를 적용할지 지정

![ALU 다이어그램](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%89%E1%85%A5%E1%86%BC%20e0da915beee94222bf08cb6f9d89301c/Untitled%201.png)

ALU 다이어그램

### **제어 장치(Control Unit)**

- 명령어를 해석하고 레지스터와 ALU 사이의 명령 흐름을 제어
- 특정한 데이터 연산을 실행할 수 있도록 처리장치에 마이크로 연산을 구동시키는 여러가지 제어신호 제공

### **레지스터**

- CPU내부에 있는 기억장치
- CPU 내부 메모리이기에 다른 기억 장치보다 엑세스 속도가 상당히 빠름
- 산술 연산 논리장치에 의해 사용되는 **범용 레지스터** / PC 등 특수 목적에 사용되는 **전용 레지스터**로 구분
- IR (Instruction Register) : 현재 수행 중에 있는 명령어 부호를 저장하고 있는 레지스터
- PC (Program Counter) : 명령이 저장된 메모리의 주소를 가리키는 레지스터
- AC (Accumulator) : 산술 및 논리 연산의 결과를 임시로 기억하는 레지스터
- MAR(Memory Address Register) : CPU가 데이터를 읽거나 쓰려는 메모리 주소를 일시적으로 저장
- MBR(Memory Buffer Register) : 메모리에 읽거나 쓰려는 데이터 또는 명령을 일시적으로 저장

### 동작과정

Fetch → Decode → Execute → Write Back (반복)

1. Fetch
    - 프로그램 카운터(PC)에 들어있는 주소를 사용해 메모리에서 명령어를 읽어옴
2. Decode
    - 가져온 명령 해석
3. Execute
    - 명령 수행
4. Write Back
    - 수행 결과 기록
    

### 명령어 형식

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%89%E1%85%A5%E1%86%BC%20e0da915beee94222bf08cb6f9d89301c/Untitled%202.png)

- 명령코드(Opcode) + 피연산자(Operand의 데이터 or 데이터 주소)
- Opcode는 기계어의 일부이며 수행할 명령어를 나타내는 부호
- Operand는 하나 이상의 지정자를 가진다.

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%89%E1%85%A5%E1%86%BC%20e0da915beee94222bf08cb6f9d89301c/Untitled%203.png)

1. 0-주소 명령어
    - Opcode만 존재하고 Operand가 존재하지 않는 명령어
    - 모든 연산은 Stack메모리의 Stack Pointer가 가리키는 Operand를 이용하여 명령을 수행
    - 0주소 명령어의 모든 연산은 스택에 있는 자료를 이용해 수행하기 때문에 스택 머신이라고도 함
    - 주소의 사용 없이 스택에 연산자와 피연산자를 넣다 꺼내어 연산한 후 결과를 다시 스택에 넣으면 연산하기 때문에 원래 자료가 남지 않음
2. 1-주소 명령어
    - Operand의 개수가 하나인 명령어 형식
    - 기억장치로부터 Operand를 가져오거나 연산결과를 저장하기 위한 임시적인 장소로 누산기 레지스터(AC)를 사용
3. 2-주소 명령어
    - Operand의 개수가 2개인 명령어 형식
    - 여러 개의 범용 레지스터를 가진 컴퓨터에서 사용
    - 연산의 결과는 주로 Operand 1 에 저장되므로 Operand 1에 있던 원래 자료가 파괴됨
4. 3-주소 명령어
    - Operand의 개수가 3개인 명령어 형식
    - 여러 개의 범용 레지스터(GPR)를 가진 컴퓨터에서 사용
    - 연산 결과는 Operand 3에 기록
    

### 명령어 처리과정

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%89%E1%85%A5%E1%86%BC%20e0da915beee94222bf08cb6f9d89301c/Untitled%204.png)

### Fetch Cycle

1. MAR ← PC
    - PC가 가리키는 기억장치의 위치를 MAR에 저장
    - PC의 값이 외부 주소버스로 가기 위해서는 MAR을 거쳐야 함
2. MBR ← <[MAR], PC ← PC + 1
    - MAR을 거쳐 외부로 나감
    - 메모리(M)의 값을 찾아 데이터 버스를 타고 MBR에 저장
    - PC값 1 증가
3. IR ← MBR
    - MBR이 해석되기 위해 IR을 거쳐야 함
    
    ![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%89%E1%85%A5%E1%86%BC%20e0da915beee94222bf08cb6f9d89301c/Untitled%205.png)
    

### Execute Cycle

(명령어에 따라 과정이 달라질 수 있음)

1. 데이터 이동
    - CPU와 기억장치, I/O장치 간에 데이터를 이동
    - ex) LOAD addr
2. 데이터 처리
    - 데이터에 대하여 산술, 논리 연산 수행
    - ex) STA addr
3. 데이터 저장
    - 연산결과 데이터나 입력장치로부터 읽어들인 데이터를 기억장치에 저장
    - ex) ADD addr
4. 프로그램 제어
    - 프로그램 실행 순서를 결정
    - ex) JUMP addr
    

### ADD addr 명령어 연산

```jsx
 T0 : MAR ← IR(Addr)
 T1 : MBR ← M[MAR]
 T2 : AC ← AC + MBR
```

→ Fetch Cycle에서 가져온 ADD addr이 IR에 놓여지게 된다. 이 명령어 주소를 MAR로 보내고 기억장치의 MAR번지의 값을 MBR로 가져와서 AC의 값과 더해준 뒤, 다시 AC에 저장해준다.

---

## System Bus (시스템 버스)

- 컴퓨터의 구성요소를 서로 연결하고 데이터 전달을 위한 경로
- 제어 버스, 주소 버스, 데이터 버스로 구성
    
    ![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%89%E1%85%A5%E1%86%BC%20e0da915beee94222bf08cb6f9d89301c/Untitled%206.png)
    

### Address Bus (주소 버스)

- 메모리의 주소나 I/O Unit의 포트 번호 전달
- CPU와 Memory는 단방향으로 데이터 전달이 가능한 버스를 이용하므로 주소 전달은 CPU에서 메모리로만 가능
- CPU, Memory는 I/O Unit과 양방향으로 데이터 전달이 가능한 버스 사용

### Data Bus (데이터 버스)

- 데이터 전달
- 각 구성요소는 양방향으로 데이터 전달이 가능한 버스 사용

### Control Bus (제어 버스)

- 제어 신호 전달
- Read, Write 신호가 전달
- 각 구성요소는 양방향으로 데이터 전달이 가능한 버스 사용