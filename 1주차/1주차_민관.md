### 컴퓨터의 구조 기초

---

#### 폰 노이만 구조

![1](https://user-images.githubusercontent.com/44665707/146176705-3a37e279-4f42-45d9-9ce9-987ec7e85d7b.PNG)

- 중앙처리장치(CPU), 메모리, 프로그램 세 가지 요소로 구성
- CPU와 메모리가 분리되어있고, 둘을 연결하는 버스를 통해 명령어 읽기, 데이터의 읽고 쓰기가 가능
- 현대까지의 모든 범용 컴퓨터들이 폰 노이만 구조를 따르고 있음

- 하드웨어는 그대로두고 소프트웨어만 교체하는 방식이기에 편의성이 증가하고, 다양한 목적 사용이 가능해져 범용성 증가

---

### 컴퓨터의 구성

---

- 하드웨어 : 다양한 기계, 전자 기기, 반도체 등이 사용되는 부분. 눈에 보이는 외형을 가진 전기, 기계적인 물리적 장치
  - 중앙처리장치(CPU) 
    - 제어장치 : 명령 레지스터를 읽어들여 장치들에 신호를 보내 동작을 지시하고 제어
    - 산술논리연산장치(ALU) : 산술연산, 논리연산을 계산하는 디지털 회로 
    - 레지스터 : CPU 내부에서 처리할 명령어나 연산의 중간 결과값 등을 일시적으로 기억하는 장소
      - 특수 목적 레지스터
        1.  메모리 주소 레지스터(MAR) : 읽기 동작이나 쓰기 동작을 수행할 떄 필요한 주기억장치 주소를 저장
        2. 프로그램 카운터(PC) : 다음 번에 실행할 명령어의 주소를 기억
        3. 명령 레지스터(IR) : 현재 실행중인 명령의 내용을 기억
        4. 누산기(AC) : 연산된 결과를 일시적으로 저장
        5. 메모리 버퍼 레지스터(MBR) : 기억장치를 출입하는 데이터를 잠시 기억
        6. 베이스 레지스터 : 명령이 시작되는 최초의 주소를 기억
        7. 데이터 레지스터 : 연산에 사용될 데이터를 기억
        8. 프로그램 상태 레지스터(PSR) : CPU의 현재 상태 정보를 저장
  - 기억장치 
    - 주기억장치 : 현재 CPU가 처리하고 있는 내용을 저장하고 있는 장치, ROM과 RAM으로 나누어짐
      - ROM(Read Only Memory) : 비휘발성 메모리. 기억된 데이터를 읽기만 가능. 소멸되지 않고 반 영구적으로 사용 가능해 BIOS 같은 시스템적인 주요 데이터들이 저장
      - RAM(Random Access Memory) : 읽고 쓰기 가능. 응용 프로그램, 운영체제 등을 불러와 CPU가 작업할 수 있도록 해줌.휘발성 메모리
    - 보조기억장치 : 물리적인 디스크가 연결되어 있는 기억장치, 주기억 장치보다는 느리지만 데이터를 영구적으로 보관 가능
      - HDD(Hard Disk Driver)  : 물리적인 디스크를 고속으로 회전시켜 데이터를 저장
      - SDD(Solid State Driver) : 반도체 기반의 정보를 저장하는 기억장치, 전기적으로 데이터를 저장하기 때문에 HDD에 비해속도가 월등히 빠르고 소음발생 안함
  - 입출력장치(I/O Device) 
    - 입력장치 : 키보드, 마웃, 조이스틱 등
    - 출력장치 : 프린터, 모니터, 스피커 등
  - 시스템 버스 : 각 구성 요소가 다른 구성 요소로 데이터를 보낼수 있는 통로
    - 데이터 버스 : 중앙처리장치(CPU)와 기타 장치 사이에 데이터를 전달하는 통로, 양방향 버스
    - 주소 버스 : 데이터를 정확하게 나르기 위해서는 '주소'를 지정해주어야 함. 단방향 버스
    - 제어 버스 : 주소, 데이터 버스를 관리하고 제어하는 버스. 양방향 버스
- 소프트웨어 : 하드웨어 상에서 구동되거나 처리되는 무형물들을 뭉뚱그려 지칭
  - 시스템 소프트웨어 : 응용 소프트웨어를 실행하기 위한 플랫폼을 제공하고, 하드웨어를 동작, 접근할 수 있도록 설계
    - 운영체제(OS) : CPU 메모리, 하드디스크 등의 하드웨어를 관리, 다른 컴퓨터들과 대화할 수 있도록 도와줌 
    - 컴파일러
    - 디버거
  - 응용 소프트웨어 : 운영 체제에서 실행되는 모든 소프트웨어를 뜻함, 어플리케이션이나 앱이라고도 부름

---

### 중앙처리장치(CPU) 작동 원리

---

#### CPU의 연산과정

![2](https://user-images.githubusercontent.com/44665707/146191267-2041e4f0-ed3a-4609-bfde-d8fa242bbd4f.PNG)

- CPU가 하나의 명령(Operation)을 처리하는 과정. 읽기(Fetch) -> 해석(Decode) -> 실행(Execute) -> 기록(WriteBack)



#### CPU의 동작 과정

![3](https://user-images.githubusercontent.com/44665707/146192985-6ecf453b-d10d-45df-897c-b96664271ad0.PNG)

 (1) 보조기억장치에서 저장된 프로그램을 읽거나, 입력장치에서 입력받는 데이터를 주기억장치에서 읽음

 (2) 주기억장치에서 읽어온 데이터를 중앙처리장치(CPU)가 읽고 처리한 후 다시 주기억장치로 보내 저장

 (3) 주기억장치는 연산된 데이터를 출력 장치에 보내거나 보조기억 장치게 저장

 (4) 제어장치는 (1) ~ (3)의 과정이 순서대로 잘 실행되도록 제어 및 관리



#### CPU의 명령어

- 명령어 세트 : 실행할 연산 나타내는 연산 코드(Operation Code), 연산에 필요한 데이터나 저장 위치를 나타내는 피연산자(Operand)
  - 연산 코드 : 실행연산 종류 따라 네 가지 기능
    - 연산 기능 : 사칙연산, 이동(shift), 보수 등의 산술연산, 논리곱, 논리합, 부정 등의 논리연산 수행
    - 제어 기능 : 조건 분기, 무조건 분기 등을 사용하여 명령어의 실행 순서 제어
    - 데이터 전달 기능 : 레지스터와 레지스터 사이, 레지스터와 주기억 장치 사이에서 데이터를 전달
    - 입출력 기능 : 프로그램과 데이터를 주기억장치에 전달하고 연산 결과는 출력장치에 전달
  - 피연산자 : 주소, 숫자/문자, 논리 데이터 등을 저장
    - 주소 : 기억장치 혹은 레지스터의 주소가 저장
    - 숫자/문자 : 숫자는 정수, 고정 소수점 수, 부동 소수점 수 등 각각의 코드로 저장되고 문자는 아스키코드로 저장
    - 논리 데이터 : 참 또는 거짓을 표현



#### 명령어 사이클

- 주기억장치(CPU)에서 한 번에 하나의 명령어를 인출하여 실행하는데 필요한 일련의 활동
- 인출, 실행, 간접, 인터럽트 사이클로 세분화 할 수 있고, 인출 사이클과 실행 사이클은 항상 수행



- 인출 사이클

 ![4](https://user-images.githubusercontent.com/44665707/146194036-60f1c622-ffab-438d-a028-45382c973eb9.PNG)

1. 프로그램 카운터(PC)에 저장된 주소를 메모리 주소 레지스터(MAR)로 전달
2. 메모리 주소 레지스터(MAR)에 저장된 내용을 토대로 주기억장치의 해당 주소에서 명령어 인출
3. 인출한 명령어를 메모리 버퍼 레지스터(MBR)에 저장
4. 다음 명령어 인출 위해 프로그램 카운터(PC)값을 증가
5. 메모리 버퍼 레지스터(MBR)에 저장된 내용을 명령어 레지스터(IR)에 전달

```
T0 : MAR <- PC
T1 : MBR <- M[MAR], PC <- PC + 1
T2 : IR <- MBR
```



- 실행 사이클

![5](https://user-images.githubusercontent.com/44665707/146194730-45d4c2fa-a94e-46bf-8ddf-dd04bce3b9df.PNG)

1. 명령어 레지스터(IR)의 내용을 메모리 주소 레지스터(MAR)로 전달
2. 메모리에 저장된 데이터 값을 메모리 버퍼 레지스터(MBR)에 저장
3. 누산기(AC)에 저장된 값에 ADD 연산 실행

```
ADD addr 명령어 연산

T0 : MAR <- IR(Addr)
T1 : MBR <- M[MAR]
T2 : AC <- AC + MBR
```

- 실행 사이클에서는 프로그램 카운터(PC)를 증가시키지 않는 이유 : 이미 인출이 진행되고 명령어 실행만 하면 되는 상황이기 때문