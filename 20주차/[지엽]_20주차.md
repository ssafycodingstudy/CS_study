## 어댑터패턴

호환성 없는 인터페이스 때문에 함께 동작할 수 없는 클래스 들이 함께 작동하도록 해주는 패턴

#### 다이어그램

![img](https://s3.ap-northeast-2.amazonaws.com/yaboong-blog-static-resources/diagram/adapter-pattern-1.png)

##### Client 

써드파티 라이브러리나 외부 시스템을 사용하는 쪽

##### Adaptee

써드파티 라이브러리나 외부 시스템을 의미

##### Target Interface

Adapter가 구현하는 인터페이스, 클라이언트 Target Interface를 통해 Adaptee인 써드 파티 라이브러리 사용

##### Adapt

Client와  Adaptee 중간에서 호환성이 없는 둘을 연결시켜주는 역할 담당.



#### 어댑터 패턴 사용예제

![Coursera Design Pattern 강의 중](https://s3.ap-northeast-2.amazonaws.com/yaboong-blog-static-resources/diagram/adapter-pattern-3.png)

| **그림1**            | **그림3**    | **코드**       |
| -------------------- | ------------ | -------------- |
| **Client**           | WebClient    | AdapterDemo    |
| **Target Interface** | WebRequester | WebRequester   |
| **Adapter**          | WebAdapter   | WebAdapter     |
| **Adaptee**          | WebService   | FancyRequester |

#### 시나리오

- 기존에는 WebClient 에서는 요청에 대한 처리로 doWork() 메소드를 호출하는데, 이 처리는 WebRequester 인터페이스를 구현한 OldWebRequester 에게 위임하도록 되어있음

- 이때, WebRequester 인터페이스를 구현한 OldWebRequester 의 requestHandler() 를 호출

- 하지만 이 OldWebRequester 를 써드파티 라이브러리인 FancyRequester 로 변경해야하는 상황이 생겼다고 가정

- 이때 어댑터 패턴을 적용하여 기존의 코드와 써드파티 라이브러리 어느쪽도 수정하지 않고 FancyRequester 를 적용

#### 코드 예제

###### WebRequester «Interface»

```
public interface WebRequester {
    void requestHandler();
}
```

Target Interface 이다. 구현체를 가지지 않고 requestHandler() 메소드에 대한 정의



###### WebClient

```
public class WebClient {
    private WebRequester webRequester;

    public WebClient(WebRequester webRequester) {
        this.webRequester = webRequester;
    }

    public void doWork() {
        webRequester.requestHandler();
    }
}
```

doWork() 는 WebRequester 인터페이스를 구현한 클래스의 requestHandler() 메소드를 호출하여 동작



###### OldWebRequester

```
public class OldWebRequester implements WebRequester {
    @Override
    public void requestHandler() {
        System.out.println("OldWebRequester is working");
    }
}
```

시나리오상에서, 기존에 사용하고 있던 WebRequester 의 구현클래스로써, WebClient 에서 doWork() 를 호출하면 내부에서 호출됨

설명의 편의를 위해 작성했을 뿐, 이 예제의 Client 에서는 사용되지 않음



###### FancyRequester

```
public class FancyRequester {
    public void fancyRequestHandler() {
        System.out.println("Yay! fancyRequestHandler is called!");
    }
}
```

사용할 써드파티 라이브러리인 FancyRequester 이다. Adaptee 가 됨



###### WebAdapter

```
public class WebAdapter implements WebRequester {
    private FancyRequester fancyRequester;

    public WebAdapter(FancyRequester fancyRequester) {
        this.fancyRequester = fancyRequester;
    }

    @Override
    public void requestHandler() {
        fancyRequester.fancyRequestHandler();
    }
}
```

- WebAdapter 는 Target Interface 인 WebRequester 인터페이스를 구현하고, 인스턴스 생성시 FancyRequester 클래스를 주입. 

- (FancyRequester 는 보통 또다른 어떤 인터페이스를 구현한 클래스이겠지만, 굳이 또 만들면 이해하기 복잡해지니까 그냥 구현 클래스만 언급)

- 그리고 Target Interface 인 WebRequester 인터페이스의 requestHandler() 를 구현하는데, 이때 주입시킨 FancyRequester 의 fancyRequestHandler() 메소드를 호출

- 이렇게 하면 WebAdapter 도 WebRequester 인터페이스를 구현했으므로, WebRequester 인터페이스의 구현체를 받아 동작하던 WebClient 에 WebAdapter 를 넘겨줄 수 있고, 기존에 WebClient 에서 requesterHandler() 메소드를 호출하던 코드는 그대로 두면서도, WebAdapter 의 requestHandler() 를 통해 써드파티 라이브러리인 FancyRequester 를 사용할 수 있게 됨





## 싱글톤패턴

어떤 클래스가 최초 한번만 메모리를 할당하고 그 메모리에 인스턴스를 만들어 사용하는 디자인 패턴



#### 장점

- 고정된 메모리 영역을 얻으면서 한번의 new로 인스턴스를 사용하기 때문에 메모리 낭비를 방지

- 싱글톤으로 만들어진 클래스의 인스턴스 전역이기 때문에 다른 클래스의 인스턴스들이 데이터를 공유하기 쉬움

- 인스턴스가 절대적으로 한 개만 존재하는 것을 보증하고 싶을 경우 사용

- 두 번째 이용시 부터는 객체 로딩 시간이 줄어 성능이 좋아짐



#### 단점

- 싱글톤 인스턴스가 너무 많은 일을 하거나 많은 데이터를 공유시킬 경우 결합도가 높아짐 -> 개방-폐쇠 원칙 위배

- 객체 지향 설계 원칙에 어긋나기 때문에 수정이 어려워지고 유지보수 비용이 높아짐.

- 멀티 쓰레드 환경에서 동기화 처리를 안하면 인스턴스가 2개 생성될 수 있음



#### 싱글톤 패턴 예제 구현

```
public class CarClass{
	private static CarClass car = new CarClass();
	private CarClass(){}
	public static CarClass getInstance(){
		return car;
	}
	private static boolean isUse = false;
	
	public static void drive(){
		isUse=true;
		System.out.println("start driving");
	}
	public static void parking(){
		isUse=false;
		System.out.println("parking");
	}
	public static boolean isEnableUseCar(){
		return !isUse;
	}
}
```

최초 new를 이용해 최초 한번 객체를 생성하고 이후 해당 객체를 getInstance 메서드를 활용해 return 받아 사용함







[참고]

https://jusungpark.tistory.com/22

https://yaboong.github.io/design-pattern/2018/10/15/adapter-pattern/

https://devmoony.tistory.com/43

https://tecoble.techcourse.co.kr/post/2020-11-07-singleton/