## HTTP & HTTPS

#### HTTP(Hyper Text Transfer Protocol)

인터넷에서 데이터를 주고받을 수 있는 프로토콜



#### HTTP 동작

사용자가 브라우저를 통해서 어떠한 서비스를 url을 통하거나 다른것을 통해 요청을 하면 서버에서 응답

HTML, JSON, XML과 같은 형태로 정보를 주고 받음

서버 : 어떠한 자료에 대한 접근을 관리하는 네트워크 상의 시스템

클라이언트 : 그 자료에 접근할 수 있는 프로그램

Request : 클라이언트가 서버에게 연락하는 것

- Request : client -> server

- Response : server -> client



#### HTTP 특징

- HTTP 메세지는 HTTP 서버와 클라이언트에 의해 해석됨

- TCP/IP를 이용하는 응용 프로토콜

- HTTP는 연결상태를 유지하지 않는 비연결성 프로토콜

- HTTP는 연결을 유지하지 않는 프로토콜이기 때문에 요청/응답 방식으로 동작



#### Request Method (요청의 종류)

GET : 자료를 요청할 때 사용

POST : 자료의 생성을 요청할 때 사용

PUT : 자료의 수정을 요청할 때 사용

DELETE : 자료의 삭제를 요청할 때 사용



#### Request 메세지

```
GET https://velog.io/@surim014 HTTP/1.1								// 시작줄
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) ...			  // 헤더
Upgrade-Insecure-Requests: 1
```

#### 시작줄

- GET : HTTP Method

- 사이트주소

- HTTP/1.1 버젼

#### 헤더

- 요청에 대한 정보를 담고있음

- User-Agent, Upgrade-Insecure-Requests 등등 헤더의 해당

#### 본문

- 요청을 할 때 함께 보낼 데이터를 담는 부분.

#### Response (응답)

- 서버가 요청에 대한 답변을 클라이언트에게 보내는 것

#### Status Code (상태 코드)

- 1XX (조건부 응답) :  요청을 받았으며 작업을 계속함.

- 2XX (성공) : 클라이언트가 요청한 동작을 수신했고 성공적으로 처리함.

- 3XX (리다이렉션 완료) : 클라이언트는 요청을 마치기 위해 추가 동작을 취해야 함.

- 4XX (요청 오류) : 클라이언트에 오류가 있음

- 5XX (서버 오류) : 서버가 유효한 요청을 명백하게 수행하지 못했음.

#### Response 메세지

```
HTTP/1.1 200 OK														// 시작줄
Connection: keep-alive												 // 헤더
Content-Encoding: gzip												 
Content-Length: 35653
Content-Type: text/html;

<!DOCTYPE html><html lang="ko" data-reactroot=""><head><title...
```

#### 시작줄

- 버전 상태코드 상태메세지

#### 헤더

- 응답에 대한 정보를 담음.

#### 본문

- 요청한 데이터를 담아서 보내주기 때문. HTML을 화면에 랜더링

## HTTPS (Hyper Text Transfer Protocol Secure)

서버와 클라이언트 사이의 모든 통신 내용이 암호화

#### 암호화 방식

공개키 암호화 방식과 대칭키 암호화 방식을 함께 사용

#### 동작과정

어떤식으로 사이트가 안전하게 사용자와 통신을 하는지...

![](https://t1.daumcdn.net/cfile/tistory/99F0FA445C456BB809)

- 인터넷사이트(서버)는 공개키와 개인키를 만들고 신뢰할 수 있는 인증기관(CA)에 자신의 정보와 공개키를 관리해달라고 계약

- 이 때, 계약을 완료한 인증 기관은 기관만의 공개키와 개인키를 가짐. 사이트는 개인키로 사이트에서 제출한 정보를 암호화 해서 인증서를 만들어 제공

- 인증기관은 웹 브라우저에 공개키 제공

![](https://t1.daumcdn.net/cfile/tistory/993364345C457AED30)

- 사용자가 사이트에 접속하면 서버는 자신의 인증서를 웹 브라우저(클라이언트)에게 보냄

- 웹 브라우저가 index.html 파일을 달라고 요청했다면, 서버의 정보를 인증 기관의 개인키로 암호화한 인증서를 받게 되는 것

- 웹 브라우저는 3.에서 미리 알고 있던 인증기관의 공개키로 인증서를 해독하여 검증

- 그러면 사이트의 정보와 서버의 공개키를 알 수 있게 됨

- 이 부분은 보안상의 의미는 없다. 단지 해당 서버로부터 온 응답임을 확신할 수 있게 됨

- 이렇게 얻은 서버의 공개키로 대칭키를 암호화해서 다시 사이트에 보냄

- 사이트는 개인키로 암호문을 해독하여 대칭키를 얻게 되고, 이제 대칭키로 데이터를 주고받을 수 있게 됨

![](https://t1.daumcdn.net/cfile/tistory/9997354E5C457AF229)



#### HTTPS의 장단점

- HTTPS는 웹사이트의 무결성을 보호해줌.

- 웹 사이트와 사용자 브라우저 사이의 통신을 침입자가 건드리지 못하도록 함

- 가벼운 웹 서핑이라면 HTTP도 상관없지만, 사용자의 정보를 웹 서버와 주고 받아야하는 경우라면 HTTP는 정보 유출의 위험성을 갖게 됨

- HTTPS는 침입자가 웹사이트와 사용자 사이의 통신을 몰래 수신하는 것을 방지함으로써 보안을 강화

- getUserMedia()를 통한 사진 촬영이나 오디오 녹음, 프로그레시브 웹 앱과 같은 강력한 웹 플랫폼 신기능들은 실행하려면 사용자의 명시적인 권한 허락을 필요로 함

- [지오로케이션](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/Using_geolocation) API와 같은 오래된 API들도 실행할 때 권한이 필요하도록 업데이트되고 있는데, HTTPS는 이러한 새 기능과 업데이트된 API에 대한 권한 허락을 가능하게 함

- 네이버, 다음은 물론이고 구글 역시 검색 엔진 최적화(SEO: Search Engine Optimization) 관련 내용을 HTTPS 웹사이트에 대해서 적용

- 즉, 키워드 검색 시 상위 노출되는 기준 중 하나가 보안 요소

- 모든 사이트에서 텍스트를 암호화해서 주고 받으면 과부하가 걸려 속도가 느려질 수 있음

- 중요한 사이트는 HTTPS로 관리하고, 그렇지 않은 사이트는 HTTP를 사용함

- HTTPS를 지원한다고 해서 무조건 안전한 것은 아님

- 신뢰할 수 있는 CA 기업이 아니라 자체적으로 인증서를 발급할 수도 있고, 신뢰할 수 없는 CA 기업을 통해서 인증서를 발급받을 수도 있기 때문





## TLS/SSL HandShake

#### TLS HandShake

HTTP는 패킷을 잡아서 보면 클라이언트와 서버가 주고받는 모든 데이터를 볼 수 있음 -> 불안함

#### HTTP + TLS(SSL) = HTTPS가 등장

1. Client Hello(접속)

   클라이언트가 서버에게 다음과 같은 정보를 전송

   - 클라이언트에서 생성한 랜덤 값

   - 클라이언트가 지원하는 암호화 방식

   - 이전에 HandShake가 일어난 경우 Session ID



2. Server Hello(응답)

   서버가 클라이언트에게 다음과 같은 정보를 전송

   - 서버에서 생성한 랜덤 값

   - 클라이언트가 제공한 암호화 방식 중 서버가 선택한 암호화 방식

   - 인증서



3. Server Certificate ~ Server Hello Done(CA리스트 확인)

   - 클라이언트는 서버가 제공한 인증서가 CA에 의해 제공된 것인지 확인하기 위해 브라우저가 가지고 있는 CA리스트를 확인 
     - CA - Certificate Authority

   - 리스트에 없다면 경고, 있다면 Public Key(공개키)를 사용해 인증서가 복호화 되는지 확인

   - 복호화가 된다면 서버는 해당 CA에 의해 인증되었음을 뜻함

   - 이 과정에서 Public Key를 얻을 수 있음



4. Exchange Pre-master Secret(복호화)
   - 클라이언트는 1에서 생성한 랜덤값과 2에서 생성한 랜덤값을 조합해 Pre-master Secret(대칭키)라는 대칭키를 생성
     - 또한 서버의 공개키를 사용해 Pre-master Secret를 암호화 시키고 서버에 전송



5. Master Secret, Session Key(핸드셰이크 종료)

   - 서버는 PrivateKey를 통해 Pre-master Secret Key를 복호화하고 서버와 클라이언트 모두 일련의 과정을 거쳐 Master Secret라는 값을 얻음

   - Master Secret은 Session Key 값을 생성, 생성된 Session Key는 데이터의 송수신 시에 대칭키 값으로 사용

   - 해당 세션이 만료되면 폐기



6. 공개키 방식을 데이터 교환에 사용하지 않는 이유
   - 공개키 방식이 더 많은 리소스를 잡아먹음  

[참고]

https://velog.io/@surim014/HTTP%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80

https://rachel-kwak.github.io/2021/03/08/HTTPS.html

https://velog.io/@kykevin/TLS-Handshake-%EC%9D%98-%EC%9D%B4%ED%95%B4

https://rat2.tistory.com/5