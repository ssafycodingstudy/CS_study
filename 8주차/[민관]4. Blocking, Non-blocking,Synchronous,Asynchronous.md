### 블로킹과 논블로킹

- 제어권 : 자신(함수)의 코드를 실행할 권리 같은 것, 제어권을 가진 함수는 자신의 코드를 끝까지 실행한 후, 자신을 호출한 함수에게 돌려줌
- 블로킹과 논블로킹은 A함수가 B함수를 호출했을 때, 제어권을 어떻게 처리하느냐에 따라 달라짐

1. 블로킹

   ![7](https://user-images.githubusercontent.com/44665707/154792247-c50593eb-c542-439a-88ff-56ae10b8ec23.PNG)

   - A함수가 B함수를 호출하면, 제어권을 A가 호출한 B 함수에 넘겨줌
   - 제어권을 넘겨받은 B는 열심히 함수를 실행함. A는 제어권이 없기에 함수 실행 멈춤
   - B함수는 실행이 끝나면 자신을 호출한 A에게 제어권 넘겨줌

2. 논블로킹

![8](https://user-images.githubusercontent.com/44665707/154792298-87615e1b-7617-4408-8c03-c5853cb71e5d.PNG)

- A함수가 B함수를 호출해 B함수가 실행되지만, 제어권은 A함수가 그대로 가지고 있음
- A함수는 계속 제어권을 가지고 있기 때문에 B함수를 호출한 이후에도 자신의 코드를 계속 실행



### 동기와 비동기

- 호출되는 함수의 작업 완료 여부를 신경쓰는지의 차이

1. 동기
   - 함수 A가 함수 B를 호출한 뒤, 함수 B의 리턴값을 계속 확인하면서 신경 씀
2. 비동기
   - 함수 A가 함수 B를 호출할 때 콜백 함수를 함께 전달해서, 함수 B의 작업이 완료되면 함께 보낸 콜백 함수 실행
   - 함수 A는 호출 이후로 함수 B의 작업 완료 여부에 신경쓰지 않음



### 혼합

1. Sync-Blocking

![9](https://user-images.githubusercontent.com/44665707/154792395-a2b75268-feda-4420-a2ad-0b63d7f10d58.PNG)

- 함수 A는 함수 B의 리턴값 필요(동기), 그래서 제어권을 함수 B에게 넘겨주고, 함수 B가 실행 완료해 리턴값과 제어값 돌려주길 기다림(블로킹)

2. Sync-Nonblocking

![10](https://user-images.githubusercontent.com/44665707/154792424-14061908-8d4f-4932-b0a5-fb1d3a6f47bb.PNG)

- A함수가 B함수 호출, 이때 B함수에게 제어권은 주지않고 자신의 코드 계속 실행(논블로킹)
- A함수는 B함수의 리턴값이 필요하기 때문에 중간중간 B함수에게 함수 실행 완료했는지는 물어봄(동기)

3. Async-Nonblocking

![11](https://user-images.githubusercontent.com/44665707/154792464-d27a6301-1f84-455a-8055-29b437897cc3.PNG)

- A함수가 B함수를 호출할때 제어권을 주지않음(논블로킹)
- B함수를 호출할 때 콜백함수도 함께 주고, B함수가 자신의 작업 끝나면 콜백 함수 실행시킴(비동기)

4. Async-Blocking

![12](https://user-images.githubusercontent.com/44665707/154792501-f056848f-1420-47e4-9513-cb21affd9365.PNG)

- A함수는 B함수 리턴값에 신경쓰지 않고 콜백함수 보냄(비동기), 그런데 제어권을 B함수에 넘김(블로킹)
- A함수는 자신과 관련 없는 B함수의 작업이 끝날 때까지 기다려야함. 비효율적이라 마주하기 어려움
- 사실상 sync-blocking이나 크게 다를게 없어 잘 사용하지 않음

