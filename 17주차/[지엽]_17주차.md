## 객체지향 프로그래밍

#### OOP(객체지향 프로그래밍) -JAVA, C#

문제를 여러개의 객체 단위로 나눠 작업하는 방식

객체들이 서로 유기적으로 상호작용하는 프로그래밍이론



#### OOP의 장점

- 코드 재사용성 증가
  - 상속을 통해 코드의 재사용을 높임

- 생산성 향상
  - 독립적인 객체를 사용함으로써 개발의 생산성을 향상

- 자연적인 모델링
  - 생각하고 있는 것을 그대로 자연스럽게 구현

- 유지보수의 우수성
  - 캡슐화를 통해 주변 영향이 적기 때문에 유지보수가 쉬움

#### OOP의 단점

- 개발속도가 느림
  - 객체가 처리하려는 것에 대한 정확한 이해가 필요, 설계단계부터 많은 시간이 소모

- 실행속도가 느린점
  - 객체지향언어는 대체적으로 실행속도가 느림

- 코딩 난이도 상승
  - 복잡해져 코딩의 난이도가 상승

#### OOP 특징

클래스를 이용해 연관있는 처리부분(함수)과 데이터부분(변수)을 하나의 객체(인스턴스)로 묶어 생성해 사용

- 캡슐화

  - 데이터와 코드의 형태를 외부로부터 알 수 없게 하고 데이터의 구조와 역할, 기능을 하나의 캡슐형태로 만드는 것

  - 변수를 private로 선언 -> 데이터를 보호

  - 보호된 변수는 getter와 setter로 메서드를 통해서 간접적으로 접근

  - 정보은닉을 할 수 있다는 특징 -> 캡슐화와 정보은닉은 동일한 개념은 아님



- 추상화

  - 객체의 공통적인 속성과 기능을 추출하여 정의

  - 프로그램으로 만들기 위해 공통특성을 파악해 필요없는 특성을 제거하는 과정

  - 클래스는 객체들이 어떤 특징들이 있어햐 한다고 정의하는 추상화된 개념

  - 객체들의 공통된 특징을 파악해 정의해놓은 설계기법



- 상속

  - 기존 상위클래스에 기능을 가져와 재사용할 수 있으면서도 동시에 새로운 하위 클래스에 새로운 기능도 추가 할 수 있는 것

  - 상속이 필요한 이유는 코드의 중복을 없애기 위해서 임

  - 상속 관계를 맺으면 자식객체를 생성할 때 부모클래스의 속성들을 자동으로 물려받기 때문에 자식 클래스에서 또 정의할 필요가 없음



- 다형성

- 상속과 연관있는 개념 한객체가 상속을 통해 기능을 확장하거나 변경하여 다른 형태로 재구성되는 것

- 오버로딩과 오버라이딩이 대표적인 예

  - 오버라이딩은 하위클래스가 상위클래스에서 만들어진 메서드를 자신의 입맛대로 다시 재창조해 사용하는 것

  - 오버로딩은 하나의 클래스 안에서 같은 이름의 메서드를 사용, 각 메서드마다 다른 용도로 사용되고 결과물도 다름

  - 오버로딩이 가능하려면 메서드 끼리 이름은 같지만 매개변수 개수나 데이터 타입이 달라야 함.

- 다형성을 사용하면 같은 이름의 속성을 유지, 인터페이스를 유지하고 메서드 이름을 낭비하지 않음

- API가 많아질수록 복잡성은 증가하기 때문에 다형성이 유용해짐

- 코드 재사용 성을 늘려주고 유지보수가 용이하도록 도와주는 개념
  - API란 (Application Programming Interface)
    - 프로그램들이 서로 상호작용하는 것을 도와주는 매개체
      1. 서버와  DB에 대한 출입구 역할
      2. APP과 기기가 원활하게 통신이 되도록 함
      3. 모든 접속을 표준화함






## 함수형 프로그래밍

자료처리를 수학적 함수의 계산으로 취급하고 상태와 가변데이터를 멀리하는 프로그래밍 패러다임

다른 방식으로 사고하는 법을 배우는 것 - > 유연한 문제해결이 가능

#### 함수형 프로그래밍의 특징

1. 순수함수(Pure function)

   - 동일한 입력에는 항상 같은 값을 반환해야하는 함수

   - 함수의 실행이 프로그램의 실행에 영향을 미치지 않아야 하는 함수

   - 함수 내부에서 인자의 값을 변경하거나 프로그램 상태를 변경하는 Side Effect가 없는 것

```
let num = 1;

function add(a) {
    return a + num;
}
//전역 변수 num을 참조하기 때문에 순수함수라 볼 수 없음
```

```
// 순수함수
function add(a, b) {
    return a + b;
}

const result = add(2, 3);
```



2. 비상태, 불변성(Stateless, Immutability)

   - 함수형 프로그래밍에서의 데이터는 변치않는 불변성을 유지

   - 데이터의 변경이 필요한 경우, 데이터 복사본을 만들어서 작업을 진행.

```
let person = { name: "jongmin", age: "26" };

function increaseAge(person) {
    person.age = person.age + 1;
    return person;
}
//age를 직접 변경시키므로 불변성 x
```

```
// 비상태, 불변성 만족
const person = { name: "jongmin", age: "26" };

function increaseAge(person) {
    return { ...person, age: person.age + 1 };
}
//데이터 복사본을 만들어 작업을 진행
```



3. 선언형 함수(Expressions)

   - 명령형 프로그래밍은 무엇을 어떻게 할 것인가에 주목하고, 선언형 프로그래밍은 무엇을 할 것인가에 주목함.

   - if, switchm for등을 사용하지 않고 함수형 코드로 사용해야 함



4. 1급 객체와 고차함수(First-class, Higher-order functions)

- 함수가 1급 객체가 됨

##### 1급 객체의 특징

- 변수나 데이터 구조안에 담을 수 있음

- 파라미터로 전달 할 수 있음

- 반환값으로 사용할 수 있음

- 할당에 사용된 이름과 관계없이 고유한 구별이 가능

- 동적으로 프로퍼티 할당이 가능

```
// 1급 객체
const addTwo = (num) => num + 2;
const multiplyTwo = (num) => num * 2;
const transform = (numbers) => numbers.map(addTwo).map(multiplyTwo);

console.log(transform([1, 2, 3, 4])); // [6, 8, 10, 12]
```

##### 고차 함수의 속성

- 함수를 인자로써 전달 할 수 있어야 함.

- 함수의 반환값으로 또 다른 함수를 사용할 수 있음

```
// 고차 함수
const addInform = (name) => (age) => age + name;
const jongmin = addInform("종민");

console.log(jongmin("96")); // 96종민
```



#### 함수형 프로그래밍의 장단점

##### 장점

높은 수준의 추상화를 재공

함수 단위의 코드 재사용이 수월함

불변성을 지향하기 때문에 프로그램의 동작 예측이 쉬움

##### 단점

순수함수를 구현하기 위해서는 코드의 가독성이 좋지 않을 수 있음

재귀적 스타일을 많이 이용하기 때문에 무한 루프에 빠질 수 있음

조합하는 것이 쉽지 않음

[참고]

https://velog.io/@gillog/OOP%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D

https://mangkyu.tistory.com/111

https://jongminfire.dev/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80