# 13주차 CS 발표

## 인덱스(Index)

### 인덱스란?

추가적인 쓰기 작업과 저장 공간을 활용하여 **데이터베이스 테이블의 검색 속도를 향상**시키기 위한 자료구조

만약 책에서 원하는 내용을 찾는다고하면, 책의 모든 페이지를 찾아보는 것은 오랜시간이 걸리기 때문에 책의 색인을 활용하는데, 데이터베이스의 index는 책의 색인과 같음

데이터베이스에서도 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 도와줌



![img](https://blog.kakaocdn.net/dn/cBQD97/btqKRtpm2pl/rmo7jTbiiE9tsSQsUg0JPK/img.png)

인덱스를 활용하면 데이터를 조회하는 SELECT 외에도 UPDATE나 DELETE의 성능이 함께 향상됨

해당 연산을 수행하려면 해당 대상을 조회해야만 작업을 할 수 있기 때문

```sql
// Hyemin이라는 이름을 업데이트 해주기 위해서는 Hyemin을 조회해야함
UPDATE USER SET NAME ='LeeHyemin' WHERE NAME = 'Hyemin'
```

만약 index를 사용하지 않은 컬럼을 조회해야하는 상황이라면 전체를 탐색하는 Full Scan을 수행해야 함

Full Scan은 전체를 비교하여 탐색하기 때문에 처리 속도가 떨어짐



### 인덱스의 특징

#### 인덱스는 WHERE 절에서 효과가 있음

인덱스는 SELECT - FROM - WHERE 절 중 `WHERE` 절에 사용할 컬럼에 대한 효율화라고 볼 수 있음

`WHERE` 절을 사용하지 않고 인덱스가 걸린 컬럼을 조회하는 것은 성능에 아무런 영향이 없음

> 예를 들어, `학생` 테이블에 '학번', '이름', '전화번호'가 있다고 가정
>
> 인덱스는 '학번', '전화번호'에 걸려 있음
>
> 다음 중 인덱스가 영향을 주는 쿼리는?
>
> - 1번) `SELECT '학번' FROM '학생';`
> - 2번) `SELECT '전화번호' FROM '학생' WHERE '이름' = "김철수";`
> - 3번) `SELECT * FROM '학생' WHERE '학번' = 1;`
>
> 정답은 3번
>
> `WHERE` 절에 사용할 때 성능을 향상시킴



#### 인덱스를 무조건 많이 설정하면 좋은것인가

인덱스는 하나 혹은 여러개의 컬럼에 대해 설정할 수 있음

단인 인덱스를 여러 개 생성할 수도 있고, 여러 컬럼을 묶어 복합 인덱스를 설정할 수도 있음

그러나 무조건 많이 설정하는게 검색 속도 향상을 높여주지는 않음

인덱스는 데이터베이스 메모리를 사용하여 테이블 형태로 저장되므로 **개수와 저장 공간은 비례함**

따라서 **조회 시 자주 사용하고**, **고유한 값 위주로** 인덱스를 설정하는 게 좋음



### 인덱스의 관리

 DBMS는 index를 항상 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있음.

그렇기 때문에 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 각각 다음과 같은 연산을 추가적으로 해주어야 하며 그에 따른 오버헤드가 발생함

- INSERT : 새로운 데이터베이스에 대한 인덱스를 추가함
- DELETE : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행함
- UPDATE : 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대한 인덱스를 추가

UPDATE, DELETE는 WHERE 절에 잘 설정된 인덱스로 조건을 붙여주면 조회할 때 성능은 크게 저하되지 않지만

INSERT의 경우, 새로운 데이터가 추가되면서 → 기존에 인덱스 페이지에 저장되어 있던 탐색 위치가 수정되어야 하므로 효율이 좋지 않음



### 인덱스의 장점과 단점

#### 장점

- 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있음
- 전반적인 시스템의 부하를 줄일 수 있음

#### 단점

- 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요함
- 인덱스를 관리하기 위한 추가 작업이 필요함
- 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있음
  - 만약 CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 **인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과** 가 발생할 수 있음.
  - UPDATE와 DELETE는 기존의 인덱스를 삭제하지 않고 '사용하지 않음' 처리를 해주기 때문에 테이블에 UPDATE와 DELETE가 빈번하게 발생한다면 실제 데이터는 10만건이지만 인덱스는 100만건이 넘어가게 되어  SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능이 떨어지게 될 것



### 인덱스 설정 기준

|                             기준                             |     정도      |
| :----------------------------------------------------------: | :-----------: |
|                 카디널리티<br />(중복 정도)                  | 높을수록 적합 |
| 선택도<br />(특정 필드값을 지정했을 때 선택되는 레코드 수를 테이블 전체 레코드 수로 나눈 값) | 낮을수록 적합 |
| 활용도<br />(실제 작업에서 얼마나 활용되는지에 대한 값, where 절에 자주 활용되는지 판단) | 높을수록 적함 |
|           중복도<br />(중복 인덱스 여부에 대한 값)           | 없을수록 적합 |

- 규모가 작지 않은 테이블
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼 

위의 경우에 인덱스를 사용하면 좋음



### 인덱스의 자료구조

인덱스를 구현하기 위해서는 다양한 자료구조를 사용할 수 있는데, 가장 대표적으로 해시테이블과 B+Tree가 있음



#### 해시테이블

(Key, Value)로 데이터를 저장하는 자료구조 중 하나고, 빠른 데이터 검색이 필요할 때 유용함

Key값을 이용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조

![img](https://blog.kakaocdn.net/dn/RpMoO/btqKMzdg9TX/XYkGt2kqE0hr9rqhHx3o3K/img.png)

해시 테이블 기반의 DB 인덱스는 (컬럼의 값, 데이터의 위치)를 (Key, Value)로 사용하여 컬럼의 값으로 생성된 해시를 통해 인덱스를 구현했음

시간복잡도는 O(1)이며 매우 빠른 검색을 지원함

하지만 해시는 등호(=) 연산에만 특화되었기 때문에 부등호 연산 (<,>)이 자주 사용되는 데이터베이스 검색을 위해서는 적합하지 않음

이러한 이유로 데이터베이스 인덱스에는 B+Tree가 일반적으로 사용됨



#### B+Tree

DB의 인덱스를 위해 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조

B+Tree는 모든 노드에 데이터(Value)를 저장했던 B-Tree와 다른 특성을 가지고 있음

- 리프노드(데이터노드)만 인덱스와 함께 데이터(Value)를 가지고 있고, 나머지 노드(인덱스노드)들은 데이터를 위한 인덱스(Key)만을 가짐
- 리프노드들은 LinkedList로 연결되어있음
- 데이터노드 크기는 인덱스노드의 크기와 같지 않아도 됨

데이터베이스의 인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생될 수 있음

이러한 이유로 B-Tree의 리프노드들은 LinkedList로 연결하여 순차 검색을 용이하게 하는 등 B-Tree를 인덱스에 맞게 최적화하였음

*하지만 Best Case에 대해 리프노드까지 가지 않아도 탐색할 수 있는 B-Tree에 비해 무조건 리프노드까지 가야한다는 단점도 있음*

이러한 이유로 B+Tree는 O(𝑙𝑜𝑔2𝑛)의 시간복잡도를 갖지만 해시테이블보다 인덱싱에 더욱 적합한 자료구조가 되었음

<img src="https://blog.kakaocdn.net/dn/bRiL19/btqBTMSBCWF/J3nKw2qympUVxGThnVdLK0/img.png" alt="img" style="zoom:55%;" /> 






---

[참고 1] : <https://mangkyu.tistory.com/96>

[참고 2] : <https://yurimkoo.github.io/db/2020/03/14/db-index.html>

[참고 3] : <https://zorba91.tistory.com/293>
