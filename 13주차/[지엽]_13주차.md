## 정규화(Normalization)

관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스

1. 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법, 데이터를 분해하는 과정

2. 불필요한 데이터를 제거함

3. 데이터 저장을 **논리적으로** 함.



#### 목적

1. 불필요한 데이터를 제거, 데이터의 중복을 최소화 하기 위함(테이블간 조인을 통해 효율적으로 사용)

2. 데이터베이스 구조 확장 시 재 디자인을 최소화(데이터 추가로 인한 확장시)

3. 다양한 관점에서의 쿼리를 지원(조인을 통해 원하는 정보를 가져올 수 있음)

4. 무결성 제약조건의 시행을 간단하게 하기 위함(데이터의 정확성, 일관성, 유효성 유지)

5. 각종 이상현상을 방지하기 위해 테이블의 구성을 논리적, 직관적으로 함



#### 정규화 과정

![](https://media.vlpt.us/images/bsjp400/post/140f510e-26ed-4807-a517-bc0b9a902c69/image.png)

#### 1NF(부분적 함수 종속 제거)

1. 어떤 릴레이션에 속한 모든 도메인이 원자값으로만 구성됨

2. 모든 속성에 반복되는 그룹은 나타나지 않음

3. 기본 키를 사용하여 관련 데이터의 각 집합을 고유하게 식별할 수 있음

##### 1번 사례 위반

![](https://media.vlpt.us/images/bsjp400/post/4a65fdfe-0ab7-4b9c-bdbb-0dc637ee6f52/image.png)

##### 2번 사례 위반

![](https://media.vlpt.us/images/bsjp400/post/73ade403-301a-4198-a376-35c7649401d7/image.png)



##### 1NF를 만족

![](https://media.vlpt.us/images/bsjp400/post/c0fef12f-d3dc-43dd-a61e-9b4f87e369cb/image.png)



#### 2NF(부분적 함수 종속 제거)

수행했을 경우 테이블의 모든 컬럼이 완전 함수적 종속을 만족

- 함수적 종속이란 X값에 따라 Y값이 결정될 때 X->Y로 표현 Y가 X에 함수적 종속이라 표현
  - X가 결정자  Y는 종속자

- X의 값이 여러 요소일 경우 {X1, X2} -> Y 일경우 X1과 X2가 Y 의 값을 결정할 때 이를 완전 함수적 종속, 

- 둘중 하나만 결정할 때 부분 함수적 종속

![](https://media.vlpt.us/images/bsjp400/post/8ad4eeb2-c7e4-48a8-9189-d19d43aea836/image.png)

{Model, Manufacturer} -> Model Full Name을 알 수 있음

Manufacturer country는 manufacturer로 결정(부분 함수 종속)

Model과 Manufacturer Country는 아무 연관 없음

##### 2NF를 만족

![](https://dl.dropboxusercontent.com/s/x8481598dhnpzeg/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202018-12-03%2010.58.15.png)

#### 3NF (이행적 함수 종속 제거)

릴레이션이 제 2 정규화 됨

기본키가 아닌 속성들은 기본 키에만 의존해야 함.

##### 2번 조건을 위반한 사례

![](https://media.vlpt.us/images/bsjp400/post/ec532540-08d9-4a42-933c-647dd50c6491/image.png)

{Tournameent, Year}가  후보키가 됨. 

Winner Datee of Birth은 기본키가 아닌 속성인 Winner를 거쳐 기본키에 의존

##### 3NF 적용사례

![](https://media.vlpt.us/images/bsjp400/post/2feb98be-9dd6-423c-b39b-27a09e007c18/image.png)

이 경우 date of birth -> winner/ winner -> {tournament, year}가 되면서 완전 함수적 종속 관계가 됨



#### BCNF(Boyce-Codd Normal Form) 정규형

3NF를 만족하면서 모든 결정자가 후보키 집합에 속함

![](https://media.vlpt.us/images/bsjp400/post/6a0eb5f4-3150-432d-85a5-386caec90096/image.png)

{학생, 과목}이 후보키가됨.

교수가 정해지면 과목이 결정되기 때문에 교수는 슈퍼키가 됨.



![](https://media.vlpt.us/images/bsjp400/post/e3b04133-3325-4895-9dd5-672c87c3acba/image.png)

![](https://media.vlpt.us/images/bsjp400/post/87511ae9-3331-44cf-a621-f122954a6d2f/image.png)

테이블을 분리해 BCNF를 만족시킴.



#### 4NF(제 4 정규화)

속성의 값이 원자값이 아닌 값을 여러개 갖는 릴레이션을 분해하여 속성의 값이 원자값을 갖도록 하는 정규형

다치종속성 : 두개의 독립된 속성이 1:N관계로 대응하는 것

회원정보는 이름과 주문도서와 다치 종속성 관계이다.

| **회원번호** | **이름** | **주문 도서**      |
| ------------ | -------- | ------------------ |
| 121212       | 김애용   | 라푼젤             |
| 131313       | 박꿀꿀   | 잠자는 숲속의 공주 |
| 131313       | 박꿀꿀   | 백설공주           |
| 141414       | 이멍멍   | 인어공주           |
| 141414       | 이멍멍   | 미녀와 야수        |

#####  제 4 정규화를 진행 두개의 릴레이션으로 분리

| **회원번호** | **이름** |
| ------------ | -------- |
| 121212       | 김애용   |
| 131313       | 박꿀꿀   |
| 141414       | 이멍멍   |

| **회원번호** | **주문 도서**      |
| ------------ | ------------------ |
| 121212       | 라푼젤             |
| 131313       | 잠자는 숲속의 공주 |
| 131313       | 백설공주           |
| 141414       | 인어공주           |
| 141414       | 미녀와 야수        |

#### 5NF(제 5 정규형)

조인 종속성에 대하여 모든 릴레이션 스키마의 속성이 릴레이션의 슈퍼키이면 릴레이션 스키마는 종속성 집합에 대해 제 5 정규형이라 함

여러개의 릴레이션으로 분해했을 때 모든 나눠진 릴레이션이 원래 릴레이션의 슈퍼키

더 분해할 경우 정보 손실로 인해 더 이상 분해할 수 없는 경우

- 조인 종속성이란 - 스키마의 모든 올바른 릴레이션 상태가 분해될 때 무손실 분해, 비 부가적 조인 분해여야함.



보통은 BCNF까지 만족해도 정규화 되는 경우가 많음.



## 인덱스(INDEX)

데이터 베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료구조



#### 인덱스 설정 핵심 기준 4가지

##### 카디널리티(Cardinality)

카디널리티가 높으면 인덱스 설정에 좋은 칼럼 -> 한 컬럼이 갖고 있는 값의 중복도가 낮음

##### 선택도(Selectivity)

선택도가 낮으면 인덱스 설정에 좋은 칼럼 -> 한컬럼이 갖고 있는 값 하나로 적은  row가 찾아짐

##### 조회활용도

조회 활용도가 높으면 인덱스 설정에 좋은 칼럼 -> 해당 컬럼이 실제 작업에 얼마나 활용되는지

##### 수정 빈도

수정빈도가 낮으면 인덱스 설정에 좋은 칼럼 -> 인덱스로 지정된 컬럼의 값이 바뀌지 않을 수록 좋음



#### 장점 - 정렬이 되어있다는 점

##### 조건 검색 WHERE 절의 효율성

인덱스 테이블 스캔시 인덱스 테이블은 데이터들이 정렬되어 저장되어 있기 때문에 조건에 맞는 데이터를 빠르게 찾아 낼 수 있음.

##### 정렬 ORDER BY 절의 효율성

이미 정렬되어 있는 데이터를 가져오기만 해면됨

##### MIN, MAX의 효율적인 처리가 가능

레코드의 시작 값과 끝 값을 한번씩 가져오기만 하면됨



#### 단점 - 정렬된 상태를 계속 유지시켜줘야 한다는 점

##### 인덱스는 DML 에 취약

INSERT, UPDATE, DELETE를 통해 데이터가 추가되거나 값이 바뀌면 정렬을 해야함.

##### 인덱스  스캔이 좋은 것은 아님

전체 데이터 중에서 10~15%이하의 데이터를 처리하는 경우에만 효율적인 경우

##### 속도 향상을 위해 인덱스를 많이 만드는건 좋지 않음

저장공간이 추가로 필요함

-> 전체적인 데이터베이스 성능 부하를 초래함



#### 인덱스의 관리

인덱스는 데이터 삭제라는 개념에서 사용하지 않는다는 개념으로 생각

INSERT :  새로운 데이터에 대한 인ㄷ덱스를 추가

DELETE : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행

UPDATE : 기존의 인덱스를 사용하지 않음 처리, 갱신된 데이터에 대해 인덱스를 추가





[참조]

https://velog.io/@bsjp400/Database-DB-%EC%A0%95%EA%B7%9C%ED%99%94-%EB%B9%84%EC%A0%95%EA%B7%9C%ED%99%94%EB%9E%80

https://zzozzomin08.tistory.com/12



https://coding-factory.tistory.com/746

https://choicode.tistory.com/27

https://velog.io/@jwpark06/%ED%9A%A8%EA%B3%BC%EC%A0%81%EC%9D%B8-DB-index-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0