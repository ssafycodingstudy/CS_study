# 6주차 CS 발표

## 파일 시스템

### 파일 시스템 (File System)

컴퓨터에서 파일이나 자료를 쉽게 발견할 수 있도록, 유지 및 관리하는 방법

저장 매체에는 수많은 파일이 있기 때문에, 이런 파일들을 관리하는 방법을 말함

#### 특징

- 사용자 영역이 아닌 커널 영역에서 동작함
- 파일을 빠르게 읽기, 쓰기, 삭제 등 기본적인 기능을 원할히 수행하기 위한 목적
- 계층적 디렉터리 구조를 가짐
- 디스크 파티션 별로 하나씩 둘 수 있음



#### 파일 시스템의 역할

- 파일 관리 : 파일 저장, 참조, 공유
- 보조 저장소 관리 : 저장 공간 할당
- 파일 무결성 매커니즘 : 파일이 의도한 정보만 포함하고 있음을 의미
- 접근 방법 : 저장된 데이터에 접근할 수 있는 방법 제공



#### 파일 시스템 개발 목적

- 하드디스크와 메인 메모리 속도차를 줄이기 위함
- 파일 관리 용이
- 하드디스크의 막대한 용량을 효율적으로 이용



#### 주요 파일 시스템

- Windows : FAT(FAT12/16/32,exFAT), NTFS

- Linux : ext(ext2/3/4)

- Mac OS : HFS, HFS+

- Google : GFS

  > GFS : Google File System으로 구글에서 사용하는 분산 파일 시스템



#### 파일 시스템의 구조

- 메타 영역 : 데이터 영역에 기록된 파일의 이름, 위치, 크기, 시간정보, 삭제 유무 등의 파일 정보
- 데이터 영역 : 파일의 데이터

> 윈도우 탐색기를 이용하여 검색할 때 메타 영역을 탐색하면서 파일을 찾음



#### 파일 접근 방법

파일이 사용될 때는 파일 접근 방법이 반드시 메모리로 적재되어야함. 어떤 시스템은 파일에 대해 단 하나의 접근 방법만 제공함

1. 순차 접근 (Sequential Access)

   - 가장 간단한 접근 방법.
   - 디스크에 있는 파일을 마치 테이프를 재생하는 것처럼 접근. 여기서의 접근 방법은 저장되어있는 레코드 순서로 접근함을 의미. </br>
   - 가장 일반적이며 편집기나 컴파일러는 보통 이러한 형식으로 파일을 접근함

   - 파일에 대한 대부분 연산은 read 와 write

   ![img](https://noep.github.io/2016/02/23/10th-filesystem/10.1.png)

   - 읽기 작업은 파일의 다음 부분부터 차례로 읽어나가며 자동적으로 현재 위치를 추적하는 파일 포인터(offset)가 자동으로 증가됨
   - 쓰기 작업은 파일의 끝에 추가하며 새로운 파일의 끝으로 파일 포인터가 이동함. 
   - 오프셋을 맨 앞이나 맨뒤로 옮길 수도 있고, 정수 n개의 레코드만큼 앞뒤로 건너뛸 수도 있음.

   순차 접근 모델은 테이프 모델에 기반하며 임의 접근 장치는 순차 접근이 가능함



2. 직접 접근 (Direct Access)

   - 특별한 순서 없이, 빠르게 레코드를 read, write 가능

   - 직접 접근을 위해서 파일은 고정 길이의 논리 레코드의 집합으로 정의되고, 직접 접근 파일은 어떠한 블록이라도 직접 접근할 수 있음. 따라서 순서의 제약이 없음

   - 파일의 디스크 모델에 기반하며, 이는 디스크가 임의의 파일 블록에 임의적 접근을 허용하기 때문

   ![img](https://noep.github.io/2016/02/23/10th-filesystem/10.2.png)

   - 현재 위치를 가리키는 cp 변수만 유지하면 직접 접근 파일을 가지고 순차 파일 기능을 쉽게 구현이 가능함
   - 대규모 정보를 접근할 때 유용하기 때문에 '데이터베이스'에 활용됨

   

3. 기타 접근

   - 직접 접근 파일에 기반하여 색인을 사용.</br>
     찾으려고 하는 레코드가 있으면 먼저 이 색인부터 찾아 그에 대응하는 포인터를 얻음. 그런 다음 그 포인터를 사용하여 파일을 직접 접근하고 원하는 레코드를 찾음
   - 크기가 큰 파일을 입출력 탐색할 수 있게 도와주는 방법
   - 파일이 아주 크면 색인 자체도 매우 커서 메모리에 다 들어가지 못할 수 있음. 그러므로 그것 자체를 파일로 만들어 주어야함. 색인 파일이 너무 커지면 그것에 대해서도 또 색인을 만들 수 있음. 일차 색인 파일(primary index file)은 이차 색인 파일의 포인터를 가지고 이는 다시 실제 자료 항목을 가리킴

   ![img](https://noep.github.io/2016/02/23/10th-filesystem/10.3.png)



### 디렉토리와 디스크 구조

통상 수천 수만 수십억 개의 파일을 하드디스크, 광학 디스크, 반도체 디스크를 포함한 임의 접근 장치에 저장하는 방법

매우 많으므로 체계적으로 구성을 갖추어야함. 그래서 디렉터리의 사용을 수반함

디렉토리는 파일 이름을 해당 디렉터리 항목으로 변환해주는 심벌 테이블로 볼 수 있음. 따라서 다양한 방법으로 구성될 수 있음

#### 디렉토리의 연산

- 파일 찾기 : 특정 파일에 해당하는 항목을 찾기 위해 탐색이 가능해야함. 특정 패턴과 일치하는 이름을 갖는 모든 파일을 찾을 수 있어야 함
- 파일 생성 : 새로운 파일들을 생성하여 디렉터리에 추가함
- 파일 삭제 : 디렉터리에서 파일 제거
- 디렉터리 나열 : 존재하는 파일들을 나열하고 내용을 보여줌
- 파일의 재명명 : 이름 바꾸기
- 파일 시스템의 순회(Traverse) : 파일 시스템의 모든 디렉토리를 순회하면서 모든 파일들을 액세스할 필요가 있음.



#### 1단계 디렉토리

가장 간단한 구조의 디렉토리

파일이 많아지거나 다수의 사용자가 사용할 경우 심각한 제약이 따름

파일들은 서로 유일한 이름을 가짐. 서로 다른 사용자라도 같은 이름 사용 불가

![10.5.png](https://noep.github.io/2016/02/23/10th-filesystem/10.5.png)

#### 2단계 디렉토리

사용자들에게 개별적인 디렉터리를 만들어줌

- UFD(User File Directory) : 자신만의 사용자 파일 디렉터리. 비슷한 구조를 가지고 있지만 오직 한 사용자만의 파일을 저장함
- MFD(Master File Directory) : 사용자의 이름이나 계정 번호로 색인되어 있고, 각 엔트리는 사용자의 UFD를 가리킴

![10.6.png](https://noep.github.io/2016/02/23/10th-filesystem/10.6.png)

특정한 파일을 참조할 시 사용자의 UFD에서만 탐색하므로 파일 이름이 충돌하는 문제가 사라짐

다른 사용자의 파일에 접근해야하는 경우는 단점이 됨



#### 트리 구조 디렉토리

2단계 구조 디렉터리를 확장하여 다단계 트리 구조로 만들 수 있음.

사용자들이 자신의 서브디렉토리를 만들어서 파일을 구성할 수 있게함.

트리 구조는 하나의 루트 디렉토리를 가지며 시스템의 모든 파일은 고유 경로를 가짐

디렉토리의 각 항목은 한 비트를 활용하여, 일반파일인지(0) 디렉터리 파일인지(1) 구분

![10.7.png](https://noep.github.io/2016/02/23/10th-filesystem/10.7.png)

통상적으로 각 프로세스는 **현재 디렉터리**를 가지고 있음

디렉터리의 경로명을 지정할 때에는 **절대 경로명**과 **상대경로명** 두가지가 있음



#### 비순환 그래프 구조 디렉토리

디렉토리들이 서브 디렉토리와 파일을 공유할 수 있도록 허용함

절대경로명/상대경로명을 이용하여 **링크**라고 불리는 새로운 디렉토리 항목을 만들 수 있음

파일을 삭제할 때 대상이 없는 포인터(danding pointer)를 남김

참조되는 파일에 참조 계수를 두어 계산함. 참조 계수가 0이 되면 현재 파일을 참조하는 링크가 존재하지 않으므로 파일을 삭제할 수 있음

![10.8.png](https://noep.github.io/2016/02/23/10th-filesystem/10.8.png)



#### 일반 그래프 디렉터리

디렉터리에서 순환이 허용되는 경우 무한루프에 빠질 수 있기 때문에 순환이 발생하지 않도록 하위 디렉터리가 아닌 파일에 대한 링크만 허용하거나, 가비지 컬렉션을 이용해 전체 파일 시스템을 순회하고 접근 가능한 모든 것을 표시함.

디렉토리를 순회할 때 링크가 있으면 우회하여 순환을 피할 수 있음

![img](https://noep.github.io/2016/02/23/10th-filesystem/10.9.png)







---

[참고 1] : <https://security-nanglam.tistory.com/228>

[참고 2] : <https://gyoogle.dev/blog/computer-science/operating-system/File%20System.html>

[참고 3] : <https://sungwookkang.com/199>

[참고 4] : <https://sungwookkang.com/200?category=618942>

[참고 5] : <https://noep.github.io/2016/02/23/10th-filesystem/>
