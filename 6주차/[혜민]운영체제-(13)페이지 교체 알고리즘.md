# 6주차 CS 발표

## 페이지 교체 알고리즘

### 가상 메모리 `지난주 내용`

- 실제 메모리 크기와 상관없이 메모리를 사용할 수 있도록 가상 메모리 주소를 사용

- 프로세스의 일부분만 메모리에 로드하고, 나머지는 보조기억장치(가상 메모리 공간)에 둠

- 가상 메모리 관리 기법 중 **페이징 기법**으로 메모리를 관리하는 운영체제에서, 필요한 페이지가 없는 경우(page-fault) 하드디스크에서 페이지를 찾아 빈 프레임에 로딩

- 여기서 또 다시 '페이지를 올릴 빈 프레임이 없을 경우'란 문제에 직면 (주기억장치에 적재되지 않았을 시)</br>
  이 때 새로 올릴 페이지와 교체할 희생 프레임(victim page)을 찾는 알고리즘을 **페이지 교체 알고리즘**이라고 함

  > 페이지 : 프로세스를 고정된 크기의 작은 블록들로 나눴을 때, 그 블록들을 페이지라고 함. </br>
  > **가상 메모리** 를 일정한 크기로 나눈 블록
  >
  > 프레임 : 페이지 크기와 같은 주기억장치 메모리 블록.</br>
  > **물리 메모리** 를 일정한 크기로 나눈 블록



### 페이지 교체 알고리즘의 종류

- OPT(Optimal) : 앞으로 가장 오랫동안 사용되지 않을 페이지 교체
- FIFO (First In First Out)
- LRU(Least **Recently** Used) : 가장 오랫동안 사용되지 않은 페이지 교체
- LFU(Least **Frequently** Used) : 참조 횟수가 가장 작은 페이지 교체
- MFU(Most Frequently Used) : 참조 횟수가 가장 많은 페이지 교체
- NUR(Not Used Recently) : 최근에 사용하지 않은 페이지 교체



#### OPT(Optimal) 

앞으로 가장 오랫동안 사용되지 않은 페이지 교체

- 가장 이상적

- 프로세스가 앞으로 사용할 페이지를 미리 알아야함 (실제 활용에서는 알 방법 없음. 구현이 불가능한 알고리즘)

- 이 알고리즘은 실제 구현 목적보다 다른 알고리즘과 비교 연구 목적을 위해 주로 사용

  ![img](https://blog.kakaocdn.net/dn/S8lUX/btq9JNyN39f/oYoWX91sjF34LkuFfuJxrk/img.png)

- 가장 오랫동안 사용되지 않을 페이지를 알고 교체하기 때문에 모든 페이지 교체 알고리즘을 통틀어 **가장 페이지 교체 수가 적음**
  - 페이지 7의 경우, 18번째에 가서 다시 쓰일 것을 미리 알고있기 때문에 페이지 2와 페이지 7을 교체 (4번째)
  - 페이지 1의 경우, 현재 올라와 있는 [2,0,1] 중 페이지 1이 가장 뒤에 쓰일 것을 알기 때문에 페이지 1과 페이지 3을 교체



#### FIFO(First In First Out)

가장 먼저 들어온 페이지를 교체

- 가장 간단한 알고리즘. 초기화 코드에 대해 적절한 방법

  > 초기화 코드 : 처음 프로세스 실행될 때 최초 초기화를 시키는 역할만 진행하고 다른 역할은 수행하지 않으므로, 메인 메모리에서 빼도 괜찮음.</br>
  > 하지만 처음 프로세스 실행시에는 무조건 필요한 코드이므로, FIFO 알고리즘을 사용하면 초기화를 시켜준 후 가장 먼저 내보내는 것이 가능

- 메모리에 가장 먼저 올라온 페이지를 먼저 내보냄

- 각 페이지가 올라온 시간을 페이지에 기록하거나, 페이지가 올라온 순서를 Queue에 저장하는 방식 등을 사용할 수 있음

- 이해가 쉽고 구현이 간단하지만, 성능은 언제나 좋다고 장담할 수 없음

  ![img](https://miro.medium.com/max/700/1*PisBTTZmXb2ZLHix7RdBCQ.png)

  - 페이지 7의 경우, 프로세스 초기에 쓰인 후 한동안 쓰이지 않기 때문에 FIFO 교체 방식이 큰 문제를 일으키지 않음

  - 페이지 2의 경우(9번째), 직전 페이지인 페이지 4로 인해 페이지 4와 페이지 2가 교체된 후, 또 다시 페이지 2를 사용하기 위해 다시 불러들임

    ![img](https://miro.medium.com/max/213/1*-RmSTtbEz1td9eAKbmiIxw.png)

    활발하게 사용 중인 페이지를 계속해서 교체한다면 **페이지 부재율이 높아지고 실행 속도가 떨어질 위험**이 있음

- 직관적으로 생각할 때 프레임의 수가 많아질수록 페이지 결함(Page fault)의 횟수는 감소함

  - Belady's Anomaly(FIFO anomaly)</br>
    실제로 그렇지 않게 되는 현상이 나타날 수 있음

  ![img](https://blog.kakaocdn.net/dn/bBk7Bp/btq9Vka7iP3/OyRlrUsTMJ4owdIJDC1KL0/img.jpg)

  ![img](https://blog.kakaocdn.net/dn/ukhyy/btq9NROjAZc/y1yPHPRuZenlX3VTUBIq01/img.jpg)

  

#### LRU(Least Recently Used)

가장 오랫동안 사용하지 않은 페이지 교체

- OPT 알고리즘은 실제 구현이 불가능하므로, OPT 알고리즘의 방식과 비슷한 효과를 낼 수 있는 방법을 사용한 것

- OPT 알고리즘은 **페이지가 사용될 시간** 을 미리 알고 있는것. 미리 하는 것이 불가능하다면, 과거의 데이터를 바탕으로 **페이지가 사용될 시간을 예측** 하여 교체하는 것은 가능. 
  **가장 오랜 기간 사용되지 않은** 데이터라면 앞으로 사용할 확률이 적을 것이라는 가정으로 페이지를 교체하는 방식을 사용

  - 시간 지역성 성질(최근에 참조된 페이지가 가까운 미래에 다시 참조될 가능성이 높은 성질) 고려

- 사용된 시간을 알 수 있는 부분을 저장하여 가장 오랫동안 참조되지 않는 데이터를 제거 (페이지마다 카운터 필요)

  - 큐로 구현 가능. 사용한 데이터를 큐에서 제거하여 맨 위로 다시 올리고, 프레임이 모자랄 경우 맨아래에 있는 데이터를 삭제

- OPT 알고리즘보다 페이지 교체 횟수가 높지만, FIFO 알고리즘보다 효율적

  ![img](https://miro.medium.com/max/700/1*2KmdY3wX68yaZnF6MwwTqg.png)

  - 페이지 2의 경우(9번째), 직전의 페이지 부재(page 4)에서 (페이지 2가 다음에 사용될 것을 모르기 때문에) [2,0,3] 중 가장 오랫동안 사용되지 않았던 페이지 2를 교체
  - 페이지 0의 경우(11번째), [4,3,2] 중 가장 오랫동안 사용되지 않았던 페이지4를 페이지 0과 교체. 실제로 페이지 4는 이후에 해당 프로세스에서 참조되는 일이 없음

- LRU 알고리즘은 많은 운영체제가 채택하는 알고리즘이며, 좋은 알고리즘이라고 평가 받고 있음.

- 단점 : 프로세스가 주기억장치에 접근할 때마다 참조된 페이지 시간을 기록해야 하므로 막대한 오버헤드가 발생.</br>
  카운터나 큐, 스택과 같은 별도의 하드웨어가 필요

  > 카운터 : 각 페이지별로 존재하는 논리적 시계(Logical Clock)로, 해당 페이지가 사용될 때마다 0으로 클리어 시킨 후 시간을 증가시켜 시간이 가장 오래된 페이지를 교체



---

### 계수 기반 (Counting-Based) 페이지 교체

페이지 참조시마다 각 페이지가 현재까지 참조된 횟수를 카운팅하는 방법. 이 방법을 통해 LFU, MFU 알고리즘을 만들 수 있음

#### LFU(Least Frequently Used)

참조 횟수가 가장 낮은 페이지 교체

- 페이지의 참조 횟수로 교체할 페이지 결정

- LRU는 직전 참조된 시점만을 반영하지만, LFU는 참조횟수를 통해 장기적 시간 규모에서의 참조 성향 고려할 수 있음

- 만약 교체 대상인 페이지가 여러개일 경우, LRU 알고리즘을 따라 가장 오래 사용되지 않은 페이지로 교체

  ![img](https://miro.medium.com/max/700/1*nIY4ek2yu3jsND7na4AF-Q.png)

- LFU 알고리즘은 초기에 한 페이지를 집중적으로 참조하다가 이후 다시 참조하지 않는 경우 문제가 될 수 있음. 앞으로 사용하지 않아도 초기에 사용된 참조 횟수가 높아 메모리에 계속 남아있기 때문

  ![img](https://miro.medium.com/max/700/1*mBZHbLoadaZEfTMkbhcJQQ.png)

  - 초기에만 쓰인 7이 메모리에 잔존해 낭비가 일어남



#### MFU(Most Frequently Used)

참조 횟수가 가장 많은 페이지 교체

- 참조 횟수가 적은 페이지가 최근에 사용된 것이기 때문에 앞으로 사용될 가능성이 높다는 판단

  ![img](https://miro.medium.com/max/700/1*e5lca52SoQeiDmy4CvykIA.png)

##### LFU와 MFU는 실제 사용에 잘 쓰이지 않음

- 구현에 상당한 비용이 듦
- 최적 페이지 교체 정책을 (LRU만큼) 제대로 유사하게 구현해내지 못하기 때문



#### NUR = NRU (Not Used Recently, Not Recently USed), 클럭 알고리즘

![img](https://blog.kakaocdn.net/dn/qfdHU/btq9PTLnM9o/7Xg5UGO0UYs3qeXjJwTiW1/img.png)

- 최근에 사용하지 않은 페이지 교체 (LRU와 근사한 알고리즘)
- 교체되는 페이지의 참조 시점이 가장 오래되었다는것을 보장하지는 못함
- 적은 오버헤드로 적절한 성능
- 동일 그룹 내에서 선택 무작위
- 각 페이지마다 두개의 비트 `참조 비트(Reference Bit)`와 `변형 비트(Modified Bit, Birty Bit)` 가 사용됨
  - 참조 비트 : 페이지가 참조되지 않았을 때 0, 호출되었을 때 1 (모든 참조 비트를 주기적으로 0으로 변경)
  - 변형 비트 : 페이지 내용이 변경되지 않았을 때는 0, 변경되었을 때 1
- 우선순위 : 참조비트 > 변형비트

---

#### 교체 방식

- Global 교체</br>
  메모리 상의 모든 프로세스 페이지에 대해 교체하는 방식
- Local 교체</br>
  메모리 상의 자기 프로세스 페이지에서만 교체하는 방식

다중 프로그래밍의 경우, 메인 메모리에 다양한 프로세스가 동시에 올라올 수 있음</br>
따라서, 다양한 프로세스의 페이지가 메모리에 존재함</br>
페이지 교체 시, 다양한 교체 알고리즘을 활용해 victim page를 선정하는데, 선정 기준을 Global로 하느냐, Local로 하느냐에 대한 차이</br>
→ 실제로는 전체를 기준으로 페이지를 교체하는 것이 더 효율적이라고 함. 자기 프로세스 페이지에서만 교체를 하면, 교체 해야할 때 각각 모두 교체를 진행해야 하므로 비효율적



---

[참고 1] : <https://doh-an.tistory.com/28>

[참고 2] : <https://medium.com/pocs/%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-page-replacement-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-650d58ae266b>

[참고 3] : <https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Page%20Replacement%20Algorithm.md>
