# 6주차 CS 발표

## 메모리

### 메인 메모리

![img](https://blog.kakaocdn.net/dn/b9RPk7/btqC4uQcH35/IaZlRdbEzYaW96aanL1X6k/img.png)

메인 메모리는 CPU가 직접 접근할 수 있는 메모리.

프로그램이 실행되려면 해당 프로그램이 복사되어 메모리에 올라와야함. 이를 프로세스라고 함.

CPU는 연산을 수행한 후 메인 메모리에 데이터를 저장하거나 필요한 데이터를 요구함



### MMU (메모리 관리 장치)

![img](https://blog.kakaocdn.net/dn/bSX19r/btqC3NWOIS5/gAF1rGpMi7ohmAkonA6MzK/img.png)

- MMU는 논리 주소를 물리주소로 변환시켜줌

- 메모리 보호나 캐시 관리 등 CPU가 메모리에 접근하는 것을 관리해주는 하드웨어

- 메모리의 공간이 한정적이기 때문에, 사용자에게 더 많은 메모리를 제공하기 위해 **가상 주소**라는 개념이 등장

  > 가상 주소는 프로그램 상에서 사용자가 보는 주소 공간이라고 보면 됨

- 이 가상 주소를 실제 물리 주소로 빠르게 변환시켜야하는데, 이를 MMU가 도와줌

- 또한 메인 메모리의 직접 접근은 비효율적이므로, CPU와 메인 메모리 속도를 맞추기 위해 캐시가 존재함



#### MMU의 메모리 보호

- 프로세스는 독립적인 메모리 공간을 가져야 하며, 다른 공간을 침범해서는 안됨

  → 따라서 한 프로세스에게 주소 영역을 설정하고, 잘못된 접근이 오면 이를 보호해야함



> **[참고] base와 limit  레지스터를 활용한 메모리 보호 기법**
>
> ![img](https://camo.githubusercontent.com/d1cf6d562e863683d43c4a26178ad484458ac547185ee156734ac88de08a6fda/68747470733a2f2f696d67312e6461756d63646e2e6e65742f7468756d622f523132383078302f3f73636f64653d6d746973746f727926666e616d653d68747470732533412532462532466b2e6b616b616f63646e2e6e6574253246646e253246354c677574253246627471754e764b4d5277482532464a4f717a636d7a3877695866304b76376f6b66477a4b253246696d672e706e67)
>
> - base 레지스터는 메모리상의 프로세스 시작 주소를 물리 주소로 저장
> - limit 레지스터는 프로세스의 사이즈를 저장
> - 프로세스에 접근 가능한 합법적인 메모리 영역(x)은 </br>
>   `base <= x < base + limit` 이라는 메모리 영역을 부여함</br>
>   이 영역 밖에서 접근을 요구하면 trap을 발생시킴



### 메모리 과할당 (Over Allocating)

실제 메모리 사이즈보다 더 큰 사이즈의 메모리를 프로세스에 할당한 상황.</br>

페이징 기법과 같은 메모리 관리 기법은 사용자가 큰 메모리를 사용하는 것처럼 느끼도록 눈속임을 통해 메모리를 할당해줌. 이 때 사용되는 것이 **가상 메모리 기법**

- 과할당 상황에는 이러한 눈속임 과정을 사용자에게 들킬 상황이 존재함

  - 프로세스 실행 도중 페이지 폴트 발생

    → 페이지 폴트를 발생시킨 페이지 위치를 디스크에서 찾음

    → 메모리의 빈 프레임에 페이지를 올려야하는데, 빈 프레임이 없음 (모든 메모리가 사용중)

- 이러한 과할당을 해결하기 위해서는  빈 프레임을 확보할 수 있어야함

  1. 메모리에 올라와 있는 한 프로세스를 종료시켜 빈 프레임을 얻음

  2. 프로세스 하나를 swap out하고, 이 공간을 빈 프레임으로 활용 **(페이지 교체)**

swapping  기법을 통해 공간을 바꿔치기하는 2번 방법과는 달리, 1번은 사용자에게 페이징 시스템을 들킬 가능성이 매우 높기때문에 하면 안됨</br>

*페이징 기법은 사용자 모르게 시스템 능률을 높이기 위해 선택한 일이므로 들키지 않게 처리해야함*

**따라서 2번과 같은 해결책을 통해 페이지 교체가 이뤄져야함**



### 페이지 교체

메모리 과할당이 발생했을 때, 프로세스 하나를 swap out해서 빈 프레임을 확보하는 것



#### 페이지 교체 과정

1. 페이지 폴트 발생

2. 페이지 폴트를 발생시킨 페이지 위치를 디스크에서 찾음

3. 메모리에 빈 프레임이 있는지 확인

   - 만약 빈 프레임이 있으면 해당 프레임을 사용

   - 빈 프레임이 없으면, 희생 프레임을 선정해 디스크에 변경 사항을 기록하고 페이지 테이블을 업데이트
     - 빈 프레임에 페이지 폴트가 발생한 페이지를 올리고, 페이지 테이블 업데이트</br>
       이 때 페이지 교체가 일어나도, 사용자가 못 느끼도록 프로세스를 문제없이 계속 수행시켜야함 ⇒ **오버헤드를 감소시켜야함**</br>
       빈 프레임이 없는 상황에서 희생 프레임을 비울 때와 원하는 페이지를 해당 프레임으로 올릴 때 총 두번의 디스크 접근이 이루어짐</br>
       *만약 페이지 교체가 많이 이루어진다면 <u>오버헤드 문제가 발생함</u>*



##### 오버헤드를 감소시키는 해결법

1. 아예 접근하는 횟수를 줄이는 방법

   모든 페이지에 내용의 변경과 관련한 변경비트를 둬서, 만약에 희생 페이지가 정해지면 그 변경비트를 확인

   - 해당 비트가 set 상태라면 </br>
     해당 페이지 내용이 디스크 상의 페이지 내용과 달라졌다는 뜻 </br>
     즉, 페이지가 메모리에 올라온 이후 한번이라도 수정이 일어났던 것. 따라서 디스크에 기록해야함
   - 해당 비트가 clear 상태라면</br>
     디스크 상의 페이지 내용과 메모리 상의 페이지가 정확히 일치하는 상황</br>
     즉, 디스크와 내용이 같아서 기록할 필요가 없음

   비트를 활용해 디스크에 기록하는 횟수를 줄이면서 오버헤드에 대한 수를 최대 절반으로 감소시키는 방법임

2. 페이지 교체 알고리즘을 상황에 따라 잘 선택해야함

   현재 상황에서 페이지 폴트를 발생할 확률을 최대한 줄여줄 수 있는 교체 알고리즘을 사용

   FIFO, OPT, LRU 등



### 캐시 메모리

주기억장치에 저장된 내용의 일부를 임시로 저장해두는 기억장치</br>
CPU와 메인메모리 간의 성능 차이에 대한 성능 저하를 줄이기 위한 대안. </br>
만약 CPU가 어떠한 데이터에 대하여 다시 재접근을 할 때, 그 데이터를 캐시 메모리에 저장해놨다면 메인 메모리까지 접근할 필요가 없음



#### 캐싱 과정

CPU에서 주소를 전달 → 캐시 기억장치에 존재하는지 확인

- 존재하면 Hit → 해당 명령어를 CPU에게 전달 → 완료

- 존재하지 않는다면 Miss

  → 명령어를 갖고 주기억장치로 접근 → 해당 명령어를 가진 데이터 인출 → 해당 명령어 데이터를 캐시에 저장 → 해당 명령어를 CPU로 전송 → 완료

캐시를 이용하면 비용을 많이 줄일 수 있지만, 효율적으로 활용하기 위해선 적중률을 극대화해야함 (캐시에 많이 활용되는 쓸모있는 정보가 들어있어야 성능이 높아짐)

적중률을 극대화시키기위해 사용되는 것이 **지역성의 원리**



#### 지역성의 원리

기억장치 내의 데이터를 균일하게 접근하는 것이 아니라, 한 순간에 특정 부분을 집중적으로 접근하는 특성

- 시간 지역성 : 최근에 참조된 주소의 내용은 곧 다음에도 참조되는 특성
- 공간 지역성 : 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성



#### 캐싱 라인

캐시를 사용할 때, 주소에 해당되는 데이터를 찾기위해 일일이 순회하는것은 비효율적임

즉, 캐시에 목적 데이터가 저장되어있을 때 바로 접근하여 출력할 수 있어야 캐시 활용이 의미가 있어짐.

따라서 캐시에 데이터를 저장할 때, 자료구조를 활용하여 메모리 주소를 함께 저장하는데 이를 **캐싱 라인**이라고 함.

즉, set이나 map 자료구조를 활용해 빠르게 원하는 정보를 찾을 수 있도록 구현함





---

[참고 1] : <https://ybdeveloper.tistory.com/61>

[참고 2] : <https://gyoogle.dev/blog/computer-science/operating-system/Memory.html>


