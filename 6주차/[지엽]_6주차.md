## 페이지 교체 알고리즘

가상 메모리 기법 : 주 기억 장치보다 더 큰 용량의 프로그램을 실행하기 위해 일부만 주 기억장치에 적재하여 사용.

페이지가 주 기억장치에 적재되지 않을 때 어떤 페이 프레임을 선택해 교체할 것인가 결정하는 방법

프레임 : 물리 메모리를 일정한 크기로 나눈 블록

페이지 : 가상 메모리를 일정한 크기로 나눈 블록



#### 페이지 교체 알고리즘의 종류

- OPT - 앞으로 가장 오랫동안 사용되지 않을 페이지 교체

- FIFO - First in First Out

- LRU - Least Recently Used : 가장 오랫동안 사용되지 않은 페이지 교체

- LFU - Least Frequently Used : 참조 횟수가 가장 작은 페이지 교체

- MFU - Most Frequently used : 참조 횟수가 가장 많은 페이지 교체

- NUR - Not Used Recently : 최근에 사용하지 않은 페이지 교체

##### OPT 

![OPT](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FS8lUX%2Fbtq9JNyN39f%2FoYoWX91sjF34LkuFfuJxrk%2Fimg.png)

- 가장 이상적

- 프로세스가 앞으로 사용할 페이지를 미리 알아야함 - > 불가능

- 비교 연구 목적을 위해 사용됨

##### FIFO - 가장 먼저 들어온 페이지를 교체

![FIFO](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FU5nSm%2Fbtq9PUpYAl8%2FWtyueVDWhp6E2nLGbNHYWK%2Fimg.png)

- 메모리에 가장 먼저 올라온 페이지를 먼저 내보냄

- 간단하고, 초기화 코드에 대해 적절한 방법

- 들어온 시간을 저장하거나 올라온 순서를 큐에 저장

- 직관적으로 생각할 때 프레임 수가 많아질수록 페이지 결함의 횟수는 감소함

- Belady's Anomaly(실제로 그렇지 않게 되는 현상이 발생 할 수 있다.)

##### LRU - 가장 오랫동안 사용하지 않은 페이지를 교체

![LRU](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb1csvE%2Fbtq9IZlYnx0%2FwbSZzZfsBkbmQ80nnf9LdK%2Fimg.png)

- 가정 : 가장 오랫동안 사용하지 않았던 데이터라면 앞으로 사용할 확률이 적음

- 시간 지역성을 고려함

- 사용된 시간을 알 수 있는 부분을 저장하여 가장 오랫동안 참조되지 않는 데이터를 제거

- 큐로 구현가능, 사용한 데이터를 큐에서 제거하여 맨 위로 올리고 프레임이 모자랄 경우 맨 아래에 있는 데이터 삭제

- 단점 : 프로세스가 주 기억 장치에 접근 할 때마다 참조된 페이지 시간을 기록해야 하므로 오버헤드가 발생함

- 카운터나 큐, 스택과 같은 별도의 하드웨어가 필요

##### LFU  - 참조 횟수가 가장 낮은 페이지를 교체

- 페이지의 참조 횟수로 교체할 페이지 결정

- LRU는 직전 참조된 시점만을 반영하지만, LFU 는 참조 횟수를 통해 장기적 시간 규모에서의 참조 성향을 고려할 수 있음

- 단점 : 가장 최근에 불러온 페이지가 교체 될 수 있음, 구현이 복잡하고 오버헤드가 발생

##### MFU - 참조 횟수가 가장 많은 페이지 교체

- 가정 : 가장 많이 사용된 페이지가 앞으로는 사용되지 않을 것

##### NUR - 클럭 알고리즘

![NUR](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FqfdHU%2Fbtq9PTLnM9o%2F7Xg5UGO0UYs3qeXjJwTiW1%2Fimg.png)

- 최근에 사용하지 않은 페이지 교체

- 교체되는 페이지의 참조 시점이 가장 오래되었다는 것을 보장하지는 못함

- 적은 오버헤드

- 동일 그룹 내에서 선택 무작위

- 각 페이지마다 두개의 비트가 사용됨(참조, 변형 비트)

- 참조 : 페이지가 참조되지 않았을 때 0 호출되었을 때 1

- 변형 : 페이지 내용이 변경되지 않았을 때는 0, 변경되었을 때 1
  - 우선순위 참조> 변형



## 메모리

- 메인 메모리,  프로그램 실행 시 필요한 주소, 정보들을 저장하고 가져다 사용할 수 있게 만드는 공간

#### MMU(Memory Management Unit)

- 메모리 관리의 핵심적인 역할을 담당

- Contiguous allocation (연속 메모리 할당)

- 논리 주소가 연속적이면 물리주소도 연속적으로 배치된다.

- Memory Protection - 잘못된 메모리 번지를 참조하지 않도록 막아주는것

#### MMU 역할

- 주소변환, 메모리 보호

#### MMU의 주요 기능

- 주소 변환 - 가상 메모리 주소를 물리 주소로 변환

- 특권 통제 - 사용자 프로그램에서 커널 영역 침범 차단

- 캐시 통제 - 캐시 가능영역과 불가 영역 설정

- 읽기 쓰기 보호 - Read/ Write 불가 영역 생성 가능

- 메모리 보호 - 각 프로세스 별 영역만 접근하도록 통제



#### MMU 주소 변환 과정

- MMU에 가상 주소 전달

- Page Table 탐색

- 물리주소 MMU에 전달

- 주소신호 발생

- Data를 CPU에 전달



#### MMU 기반 주소 관리 효과 

- 연속적 물리 주소가 아니어도 CPU는 연속적으로 주소로 인식하여 메모리 확장 효과

- 모든 프로세스 마다 동일 주소 사용, CPU의 프로세스 관리 용이 및 구현 단순화

 

#### 캐시 메모리

주기억 장치에 저장된 내용의 일부를 임시로 저장해두는 기억장치



#### 캐싱과정

1. CPU에서 주소를 전달, 해당 명령이 캐시 기억장치에 존재하는지 확인

2. 존재하면 Hit, 해당 명령어를 CPU에 전달

3. 존재하지 않는다면 MISS

4. 주기억장치로 접근

5. 해당 명령어를 가진 데이터 인출

6. 해당 명령어 데이터를 캐시에 저장

7. 해당 명령어를 CPU로 전송 

8. 캐시를 이용하면 비용을 줄일 수 있지만 적중률을 높여야함



#### 지역성의 원리

기억장치 내의 데이터를 균등하게 접근하는 것이 아니라, 어떠한 순간에 특정 부분을 집중적으로 접근

- 시간 지역성 : 최근에 참조된 주소의 내용은 곧 다음에도  참조됨

- 공간 지역성  : 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조



#### 캐싱 라인

캐시를 사용할 때 주소에 해당하는 데이터를 찾기위해 일일히 순회하는 것은 비효율적

따라서 캐시에 데이터를 저장할 때, 자료 구조를 활용하여 메모리 주소를 함께 저장

즉, map 자료 구조와 같이 빠르게 원하는 정보를 찾을 수 있도록 구현함





## 파일 시스템

컴퓨터에서 파일이나 자료를 쉽게 발견할 수 있도록 유지,관리하는 방법이다.

사용자 영역이 아닌 커널 영역에서 동작

파일을 빠르게 읽기, 쓰기, 삭제 등 기본적인 기능을 원활히 수행하기 위한 목적



#### 파일 시스템 특징 

계층적 디렉터리 구조

디스크 파티션 별로 하나씩 둘 수 있음

- 디렉토리 - 파일의 메타데이터 중 일부를 보관하고 있는 일종의 특별한 파일



#### 파일 시스템의 역할

- 파일 관리 : 파일 저장, 참조, 공유

- 보조 저장소 관리 : 저장 공간 할당

- 파일 무결성 메커니즘 : 파일이 의도한 정보만 포함하고 있음을 의미

- 접근 방법 : 저장된 데이터에 접근 할 수 있는 방법 제공



#### 파일 시스템 개발 목적

HDD와 메인 메모리 속도차 줄이기

파일 관리 용이

HDD의 막대한 용량을 효율적으로 이용



#### 파일 시스템 구조

메타 영역과 데이터 영역 두가지 영역으로 구분

- 메타 영역 : 데이터 영역에 기록된 파일의 이름, 위치, 크기, 시간정보, 삭제유무 등 파일의 정보

- 데이터 영역 : 파일의 데이터

윈도우 탐색기를 이용하여 검색할 때 메타 영역을 탐색하면서 파일을 찾음



#### File Protection

파일에 대해 누구에게 어떤 유형의 접근을 허락할 것인지에 대한 내용

#### 접근 제어방법

##### Access control Matrix 

- 사용자들과 파일들을 엑셀 파일과 같은 테이블에 행과 열로 적어두고 읽기/쓰기 접근 권한 정보를 정리

  - ACL(Access Control List) : 파일을 기준으로 누구에게 어떤 접근 권한이 있는지 표시

  - Capability : 사용자를 기준으로 자신이 접근 권한을 가진 파일 및 해당 권한 표시

##### Grouping

- 각각의 파일에 대해서 owner, group, public 세가지 그룹으로 구분

- 세 그룹의 접근 권한을 rwx 3비트로 표시

##### Password

- 파일이나 디렉토리마다 Password를 두는 방법

- 접근 권한 그룹을 가지는 공간에서는 password가 다양해지기 때문에 관리 문제가 생김

#### File System의 Mounting

파일 시스템이 여러개가 있을 때 다른 파티션에 있는 파일 시스템의 파일에 접근하려고 한다면 Mounting 이용

Mounting은 운영체제에게 마운트하려는 파일 시스템을 저장하고 있는 장치의 이름을 넘겨주고 현재의 파일 시스템에서 어디에 둘 것인지 알려주면 됨.



#### 접근 방법

##### 순차 접근

![순차접근](https://t1.daumcdn.net/cfile/tistory/23268B3D55A73DE619)

- 데이터 a/b/c가 있을 때 현재 위치에서 a에서 c로 접근하려면 b를 꼭 거쳐야하는 구조

- 현재 위치를 가리키는 포인터에서 시스템 콜이 발생할 경우 포인터를 앞으로 보내면서 read와 write를 진행, 뒤로 돌아갈 땐 지정한 offset만큼 되감기 해야함(테이프 모델)

##### 직접 접근

- 데이터 a/b/c가 있을 때, 현재 위치 a에서 c로 접근하려면 바로 건너뛰어 접근하는 구조 (Lp  레코드 판)

#### 디스크에 파일 데이터 저장 방법

##### 연속 할당(Contiguous Allocation) 

연속 데이터 저장되는 방식

- 단점 

  - 파일의 크기가 균일하지 않고 시작점이 다르기 때문에 외부단편화발생

  - 파일의 크기를 미리 키우는데 제약

- 장점

  - 한 번의 seek, rotation으로 연결되어 있는 파일들에 빠른 접근이 가능

  - 따라서 process swapping 용으로 사용하기 좋고, direct access가 가능



##### 연결 할당(Linked Allocation) 

파일의 시작 위치와 종료 위치만 디렉토리를 가지고 있고, 각 위치에 다음 위치 정보를 가지고 있는 방식

- 단점

  - 하나의 데이터 위치를 따라가면 다음 위치를 알 수 있기 때문에 직접 접근은 어렵고 순차 접근만 가능

  - 만약 한  sector가 고장나서 pointer가 유실되면 많은 부분을 잃게 됨

  - 포인터 저장곤간으로 비효율적

- 장점
  - 외부 단편화 발생하지 않음

##### 인덱스 할당

- 단점

  - 인덱스 공간으로 작은 파일의 경우 공간 낭비

  - 작은 파일의 경우 index 저장하기에 부족하기 때문에 맨 마지막에 다음 index를 적어두는 방식인 linked scheme와 multi-level index를 통해 문제를 해결 할 수 있음.

- 장점
  - 외부조각이 발생하지 않고, Direct access가 가능함

#### 디렉토리 구현 방법(Directory Implementation)

- Linear List

  - 파일 이름과 파일의 메타 데이터를 테이블 형식으로 관리

  - 구현이 간단하지만, 파일 탐색 시 linear search를 사용해야 하기 때문에 시간이 많이 소요

- Hash Table

  - 해쉬 함수를 적용하여 파일 이름의 공간을 설정

  - 해쉬 함수 특성 상 일정 범위 안에서 데이터 관리가 가능하다는 장점

  - Collision이 발생한다는 단점



#### VFS vs NFS

- VFS(Virtual File System)

  - 사용자가 파일 시스템에 접근하기 위해 시스템 콜을 할 때

  - 원래는 각자 다른 파일 시스템에 접근해야하지만 그 윗단에 추상적인 파일 시스템

  - 즉, 파일시스템 인터페이스를 두어서 사용자가 파일시스템을 편리하게 사용할 수 있음

- NFS(Network File System)

  - 원격에 있는 파일 시스템에 접근할 때 사용하게 됨

  - 클라이언트에 있는 VFS를 사용하여 NFS client 모듈과 네트워크 모듈을 거침

  - 서버측 NFS Server 모듈과 VFS를 통해 파일 시스템에 접근하게 됨

## 디렉터리 구조

#### 디렉터리 연산

- 파일찾기 : 특정 파일을 찾기 위하여 디렉토리를 탐색

- 파일 생성 : 새로운 파일들을 생성하여 디렉토리 첨가

- 파일 삭제 : 더 이상 필요하지 않은 파일들을 디렉토리에서 삭제

- 디렉토리 나열 : 디렉토리에 존재하는 파일들을 나열하고 파일에 대한 디렉토리 항목의 내용을 보여줌

- 파일의 재명명 : 파일 이름을 변경할 수 있어야함

- 파일 시스템 순회 : 파일 시스템의 여러 디렉토리를 순회하면서 파일들을 볼 수 있게 해주는 기능

#### 1단계 디렉토리(Single Level Directory)

모든 파일이 다 같은 한 개의 디렉토리 밑에 있는 개념으로 각 파일은 유일한 이름을 가져야 함

다수의 사용자에게 제약이 크다.

![](https://t1.daumcdn.net/cfile/tistory/2438763A55A73E2033)



#### 2단계 디렉토리(Two Level Directory)

각 사용자는 자신만의 사용자 파일 디렉토리를 가지고 있으며 각 디렉토리에는 오직 한사람의 파일만을 저장

- UFD : 자신만의 사용자 파일 디렉터리

- MFD : 사용자의 이름과 계정번호로 색인되어 있는 디렉터리

![](https://t1.daumcdn.net/cfile/tistory/27475F4655A73E2129)

#### 트리 구조 디렉토리

2단계 구조를 2 트리 구조라 부르듯이 여러 단계로 확장하는 일반적인 방법의 임의의 높이를 갖는 트리 구조

일반 사용자에게 자신의 서브디렉트리를 만들게 해줌

![](https://t1.daumcdn.net/cfile/tistory/261D2C3355A73E212F)



#### 비순환 그래프 디렉토리(Acyclic Graph Directory)

비순환 그래프는 디렉토리들이 서브디렉토리들과 파일들을 공유할 수 있도록 허용하는 구조로 똑같은 파일이나 서브 디렉토리가 서로 다른 서브디렉토리에 있을 수 있다.

비순환 그래프는 트리 구조 디렉토리 방식을 일반화한 것

![](https://t1.daumcdn.net/cfile/tistory/2254493C55A73E2211)



#### 일반 그래프 디렉토리(General Graph Directory)

비순환 그래프 트리구조에 문제점은 순환이 발생하지 않도록 어떻게 보장하냐는 것

2단계부터 시작해서 사용자가 서브디렉토리를 생성하면 트리 구조 형성

단순히 새로운 파일이나 디렉토리를 기존의 트리 구조 디렉토리에 추가하는 것



#### 비순환 그래프의 장점

파일을 검색하고 파일에 대한 참조의 존재 여부를 결정하는 알고리즘이 비교적 간단

- 단점

  - 그래프의 공유 부분을 두 번 순회하는 것은 좋지않다.

  - 잘못된 알고리즘은 무한 루프에 빠질 수 있음

## OSI 7계층

![](https://t1.daumcdn.net/cfile/tistory/995EFF355B74179035)

네트워크에서 통신이 일어나는 과정을 7단계로 나눈 것

- 나눈 이유는 통신이 일어나는 과정이 단계별로 파악됨

- 이상이 생기면 그 단계만 고침



#### 1계층 - 물리 계층

- 주로 전기적, 기계적, 기능적인 특성을 이용해서 통신 케이블로 데이터를 전송

- 이 계층에서 사용되는 통신 단위는 비트이며 이것은 1과 0으로 나타내어지는, 즉 전기적으로 On, off 상태라고 생각

- 이 계층에서는 단지 데이터를 전달 할 뿐 전송 데이터가 무엇인지 전혀 신경쓰지 않음

- 단지 데이터 전기적인 신호로 변환해서 주고받는 기능만 할 뿐

-> 케이블 리피터 허브 등

#### 2계층 - 데이터 링크계층

- 데이터 링크 계층(Data link layer)은 포인트 투 포인트(Point to Point) 간 신뢰성있는 전송을 보장하기 위한 계층

- 1계층을 통해 송수신되는 정보의 오류와 흐름을 관리 정보의 전달을 수행할 수 있도록 도와주는 역할

- CRC 기반의 오류 제어와 흐름 제어가 필요 오류도 찾아주고 재전송하는 기능

- 물리적으로 할당받은 MAC 주소를 가지고 통신,전송되는 단위를 프레임으로 통신

- 이더넷/HDLC/ADCCP/패킷 스위칭 네트워크/LLC/ALOHA 등 네트워크 프로토콜이 있음

->브릿지나 스위치를 통해 맥주소를 가지고 물리계층에서 받은 정보를 전달함

#### 3계층 - 네트워크 계층(Network Layer)

- 데이터를 목적기까지 가장 안전하고 빠르게 전달하는 기능(라우팅)

- 경로를 선택하고 주소를 정하고 경로에 따라 패킷을 전달해주는 것이 역할

- 라우팅, 흐름제어, 세그멘테이션, 오류제어, 인터네트워킹 등을 수행

- 서브네트의 최상위 계층으로 경로를 설정하고 청구 정보를 관리

- 개방형 시스템들의 사이에서 네트워크 연결을 설정, 유지, 해제 기능 부여

- 전송계층 사이에 네트워크 서비스 데이터 유닛(NSDU : Network Service Data Unit)을 교환하는 기능을 제공

-> 주소 부여(IP)  경로 설정(Route)

#### IP계층 

IP 패킷의 전달 및 라우팅을 담당하는 계층(네트워크 계층에 해당)

##### 주요 역할

- 데이터링크 계층의 하드웨어적인 특성에 관계없이 독립적인 역할을 수행

##### 주요 프로토콜

- 패킷의 전달을 책임지는 IP

- 패킷 전달 에러의 보고 및 진단을 위한 ICMP

- 복잡한 네트워크에서 인터네트워킹을 위한 경로를 찾게 해주는 라우팅 프로토콜

#### IP 프로토콜

TCP/IP 기반의 인터넷 망을 통하여 데이타 그램의 전달을 담당하는 프로토콜

##### 주요 기능

- IP 계층에서 IP 패킷의 라우팅 대상이 됨(Routing)

- IP 주소 지정(Addressing)

##### 특징

- 신뢰성 및 흐름제어 기능이 없음(Best-Effort Service)

- 비연결성 데이터그램 방식으로 전달되는 프로토콜(Connectionless)

- IP 패킷 헤더 내 수신 및 발신 주소를 포함(IPv4, IPv6, IP 주소)

- IP 헤더 내 바이트 전달 순서 : 최상위 바이트(MSB)를 먼저 보냄

- 경우에 따라 단편화가 필요함

- TCP, UDP, ICMP, IGMP등이 IP 데이터그램에 실려서 전송

#### 4계층 - 전송계층(Transport Layer)

- 물리적인 계층에 속함(TCP/UDP)

- 데이터를 데이터그램 단위로 처리하는 프로토콜

-	시퀀스 넘버 기반의 오류 제어 방식

- 전송계층이 패킷들의 전송이 유효한지 확인하고 실패한 패킷을 다시 전송한다는 것

- 종단간(end to end) 통신을 다루는 최하위 계층으로 신뢰성있고 효율적인 데이터를 전송

- 기능은 오류 검출 및 복구와 흐름제어, 중복검사 수행

-> 패킷 생성 및 전송 

#### TCP 프로토콜

인터넷상에서 데이터를 메세지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜

- 신뢰성

- 연결지향적

#### UDP 프로토콜

데이터를 데이터그램 단위로 처리하는 프로토콜

- 비연결성, 비신뢰성, 순서화되지 않은 데이터그램제공

- 실시간 응용 및 멀티캐스팅 가능

- 헤더가 단순함



#### 5계층 - 세션 계층(Session Layer)

- 데이터가 통신하기 위한 논리적인 연결

- 동시 송수신방식(duplex), 반이중방식(half-duplex), 전이중방식(Full duplex)

- TCP/IP 세션을 만들고 없애는 책임을 짐

-> 통신하는 사용자들을 동기화하고 오류복구 명령들을 일괄적으로 다룸

-> 통신을 하기 위한 세션을 확립/유지/중단(운영체제가 해줌)



#### 6계층 - 표현계층(Presentation Layer)

- 데이터 표현이 상이한 응용 프로세스의 독립성을 제공하고, 암호화 함.

- 사용자의 명령어를 완성 및 결과 표현. 포장/압축/암호화

#### 7계층 - 응용계층

- 응용프로세스와 직접 관계하여 일반적인 응용 서비스를 수행

- HTTP, FTP, SMTP, POP3, IMAP, Telnet 등과 같은 프로토콜이 있음

- 네트워크 소프트웨어 UI 부분, 사용자의 입출력(I/O) 부분

[참조]

https://doh-an.tistory.com/28

http://blog.skby.net/mmu-memory-management-unit/

https://ybdeveloper.tistory.com/61#toc-%EC%BA%90%EC%8B%9C%20%EB%A9%94%EB%AA%A8%EB%A6%AC

https://security-nanglam.tistory.com/228

https://sungwookkang.com/200?category=618942

https://dely.tistory.com/86

https://shlee0882.tistory.com/110