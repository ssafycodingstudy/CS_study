## MSA(MicroServiceArchitecture)

작고 독립적으로 배포 가능한 각각의 기능을 수행하는 서비스로 구성된 프레임 워크

#### 특징

- 각각의 서비스는 그 크기가 작을 뿐, 서비스 자체는 하나의 모놀리틱 아키텍쳐와 유사한 구조를 가짐
- 각각의 서비스는 독립적으로 배포가 가능해야함.
- 각각의 서비스는 다른 서비스에 대한 의존성이 최소화 되어야함
- 각 서비스는 개별 프로세스로 구동 되며, REST와 같은 가벼운 방식으로 통신되어야 함.

#### 장점

Monolithic Architecture의 문제점을 보완해줌

#### 배포관점

전체 서비스의 중단이 없음

요구사항을 신속하게 반영하고 빠르게 배포함

#### 확장관점

특정 서비스에 대한 확장성 용이

클라우드 사용에 적합한 아키텍처

#### 장애관점

장애가 전체 서비스로 확장될 가능성이 적음

부분적 장애에 대한 격리가 수월함

#### 단점

전체 서비스가 커짐에 따라 그 복잡도가 기하급수적으로 늘어남

- 성능 - 서비스 간 호출 시 API를 사용하기 때문에 통신 비용이나 Latency가 늘어남

- 테스트/ 트랜잭션 - 서비스가 분리되어 있기 때문에 테스트와 트랜잭션의 복잡성이 증가하고 많은 자원을 필요로 함

- 데이터 관리 - 데이터가 여러 서비스에 걸쳐 분산되기 때문에 한번에 조회가 어렵고 데이터의 정합성 또한 관리하기 어려움.



## 디자인 패턴 개요

#### 디자인패턴이란

소프트웨어를 설계할 때 특정한 상황에서 자주 발생하는 고질적인 문제들을 재사용할 수 있는 해결책을 말함

#### 목적

재사용성, 호환성, 유지 보수성을 높임

#### SOLID(객체지향 설계) 원칙

- 단일 책임 원칙(Single Responsibility Principle)

한 클래스는 하나의 책임만 가져야 함.

- 개방 - 폐쇄 원칙(Open/Closed Principle)

소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 함.

- 리스코프 치환 원칙(Liskov Substitution Principle)

객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 함

- 인터페이스 분리 원칙 (Interface Segregation Principle)

특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 나음

- 의존 관계 역전 원칙 (Dependency Inversion Principle)

추상화에 의존해야하고 구체화에 의존하면 안됨

상위 모듈이 하위 모듈에 의존하면 안됨



#### 디자인 패턴 분류

- 생성 패턴

​	객체 생성과 관련된 패턴으로, 객체의 생성 방식을 결정

- 구조 패턴

​	클래스나 객체간의 관계를 조직하는 패턴으로 클래스나 객체를 조합하여 구조를 만듬

- 행동패턴

​	클래스나 객체의 행위를 조직, 관리하는 패턴, 클래스나 객체 사이의 책임 분배와 관련된 패턴



[참고] 

https://mydream72.tistory.com/entry/%EC%95%8C%EA%B3%A0%EB%B3%B4%EB%8B%88-MSA%EB%9E%80

https://velog.io/@tedigom/MSA-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1-MSA%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90-3sk28yrv0e

https://readystory.tistory.com/114

https://velog.io/@cgw0519/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4-%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4-%EA%B0%9C%EC%9A%94