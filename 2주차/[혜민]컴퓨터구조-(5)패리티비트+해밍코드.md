# 2주차 CS 발표

## 패리티 비트 & 해밍 코드

### 패리티 비트

> 정보 전달 과정에서 오류가 생겼는지 검사하기위해 추가하는 비트
> 전송하고자하는 데이터의 각 문자에 1비트를 더하여 전송

종류: 짝수, 홀수
전체 비트에서 (짝수, 홀수)에 맞도록 비트를 정하는 것 



***짝수 패리티일때 7비트 데이터가 1010001 이라면?***

>1이 총 3개이므로, 짝수로 맞춰주기 위해 1을 더해야함
> 
>답: 11010001 (맨앞이 패리티비트)



### 해밍 코드

> 데이터 전송 시 1비트의 에러를 정정할 수 있는 **자기 오류정정 코드**를 말함
>
> 패리티비트를 보고, 1비트에 대한 오류를 정정할 곳을 찾아 수정할 수 있음 (패리티비트는 오류를 검출하기만 할 뿐 수정하지는 않기때문에 해밍 코드를 활용)



#### 1) 최소 패리티 비트수 결정

2^parity <= parity + data +1의 공식을 성립해야함

4개의 데이터 비트가 있다면 **2^3 = 8 = 3+4+1**로 3개의 패리티 비트가 필요함. 

등호가 아닌 부등호이기때문에 4개 이상 써도 되지만 작을수록 좋음



#### 2) 패리티 비트의 위치 결정

n번째 패리티 비트가 2^n-1의 위치에 들어감 (1,2,4,8,16,...)



#### 3) 패리티 비트 결정

패티리 범위 원소들의 XOR 연산으로 결정

![img](https://mblogthumb-phinf.pstatic.net/MjAxNzEwMDlfMzMg/MDAxNTA3NTI1OTU1OTQx._v0GEsUX2MwcYSW6Vqzwpi2KDC3Yefrn-2IHhC8ECMsg.u5erUQF-XsjEXDxyg1csjgGDAijbLYNyKnvT-JMy__Eg.JPEG.ggggamang/gd.JPG?type=w800)

***만약 데이터가 1001이라면 3개의 P비트를 (1,2,4)에 추가해서 100P1PP가 됨***

- 1번 P비트 = (1,3,5,7) = (P,1,0,1) = 1 X 0 X 1 = 0

- 2번 P비트 = (2,3,6,7) = (P,1,0,1) = 1 X 0 X 1 = 0

- 3번 P비트 = (4,5,6,7) = (P,0,0,1) = 0 X 0 X 1 = 1

  - 짝수 패리티는 각 패리티 범위의 모든 원소들 중  1의 갯수가 짝수가 되어야함 (0101/0101/1001)
  - 홀수 패리티는 반대로 홀수가 되어야함. 
  - 따라서 최종 결과는 100P1PP -> 1001100  이 됨

  

#### 4) 패리티 비트 검증

패리티 범위 (e.g. 1번 P비트 = 1,3,5,7) 값들의 XOR값이 모두 0이면 오류가 없는 것이고 만약 1이 나온다면 에러가 발생한 것.

3개의 P비트 범위에서 검출된 2진값을 10진수로 변경하여 해당 자리수 수정

(홀수 패리티의 경우 모두 1이면 오류가 없는 것이고 0이 나오면 에러가 발생한것)



***짝수 패리티의 해밍 코드가 0011011일 때 오류가 수정된 코드는?***

1. [1,3, 5, 7] 번째 비트 확인 (P1 check 범위) : 0101로 짝수이므로 '0'
2. [2, 3, 6, 7] 번째 비트 확인 (P2 check 범위) : 0111로 홀수이므로 '1'
3. [4, 5, 6, 7] 번째 비트 확인 (P4 check 범위) : 1011로 홀수이므로 '1'
4. 역순으로 패리티비트 '110'을 도출 -> 10진법으로 바꾸면 '6'이므로 6번째 비트를 수정하면 됨
5. 따라서 정답은 **00110'0'1** 이다.




---
[참조 1] : <https://gyoogle.dev/blog/computer-science/computer-architecture/%ED%8C%A8%EB%A6%AC%ED%8B%B0%20%EB%B9%84%ED%8A%B8%20&%20%ED%95%B4%EB%B0%8D%20%EC%BD%94%EB%93%9C.html>

[참조 2] : <https://gusdnd852.tistory.com/80>

