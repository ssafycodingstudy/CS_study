# 2주차 CS 발표

## 캐시 메모리

### 캐시메모리란?

메인 메모리와 CPU간의 데이터 속도 차이를 줄이기 위해 중간 버퍼 역할을 하는 CPU 내 또는 외에 존재하는 메모리

- CPU 코어와 메모리 사이의 병목 현상 완화 
-  웹 브라우저 캐시 파일은, 하드디스크와 웹페이지 사이의 병목 현상을 완화



### 캐시메모리의 특징

1. 캐시는 메인메모리와 CPU사이에 위치하며, 자주 사용하는 프로그램과 데이터를 기억함

2. 메모리 계층 구조에서 가장 빠른 소자이며, 처리속도가 거의 CPU의 속도와 비슷한 정도

3. 캐시메모리를 사용하면 메인메모리를 접근하는 횟수가 줄어들어 컴퓨터의 처리속도가 향상됨

4. 캐시 주소표는 검색시간을 단축시키기 위해 주로 연관기억장치를 사용

5. 캐시의 크기는 보통 수십 KByte ~ 수백 KByte

6. 속도라는 장점을 얻지만, 용량이 적기도하고 비용이 비싼점이 있음

7. CPU에는 캐시메모리가 2~3개정도 사용됨 (L1, L2, L3 캐시 메모리라고 부름)

   - 속도와 크기에 따라 분류한 것으로, 일반적으로 L1 캐시부터 먼저 사용됨 (CPU에서 가장 빠르게 접근하고, 여기서 데이터를 찾지 못하면 L2로 감)

   - **듀얼 코어 프로세서의 캐시 메모리** : 각 코어마다 독립된 L1 캐시 메모리를 가지고, 두 코어가 공유하는 L2 캐시 메모리가 내장됨

   - 만약 L1 캐시가 128kb면, 64/64로 나누어 64kb에 명령어를 처리하기 직전의 명령어를 임시 저장하고, 나머지 64kb에는 실행 후 명령어를 임시저장함. (명령어 세트로 구성, I-Cache - D-Cache)

   - L1 : CPU 내부에 존재. 프로세서와 가장 가까운 캐시. 속도를 위해 I-Cache와 D-Cache로 나뉨

     - Instruction Cache (I-Cache) : 메모리의 text 영역 데이터를 다루는 캐시
     - Data Cache (D-Cache) : text 영역을 제외한 모든 데이터를 다루는 캐시
     
   - L2 : CPU와 RAM 사이에 존재. 용량이 큰 캐시. 크리를 위해 L1 캐시처럼 나누지 않음

   - L3 : 보통 메인보드에 존재. 멀티 코어 시스템에서 여러 코어가 공유하는 캐시

     *캐시 메모리가 크기가 작은 이유는, SRAM 가격이 매우 비쌈* 

   - 디스크 캐시: 주기억장치(RAM)와 보조기억장치(하드디스크) 사이에 존재하는 캐시


### 캐시 메모리 작동 원리

#### CPU가 요청한 데이터가 캐시에 있으면 'Cache Hit (적중)', 없어서 DRAM에서 가져오면 'Cache Miss (실패)'라고 함

보통 CPU는 데이터를 가져오기 위해 **캐시 메모리 > 메모리 > 보조기억장치** 순으로 접근함.

- 캐시 적중일때 : 캐시 메모리의 데이터를 CPU 레지스터에 복사
- 캐시 실패 / 메모리 적중일 때 : 메모리의 데이터를 캐시 메모리에 복사하고, 캐시 메모리의 복제된 내용을 CPU 레지스터에 복사
- 캐시, 메모리 실패일 때 : 보조 기억장치에서 필요한 데이터를 메모리에 복사. 메모리에 복제된 내용을 캐시 메모리에 복제. 캐시 메모리의 복제된 데이터를 CPU 레지스터에 복제함.

=> 캐시 메모리에 최대한 많은 데이터를 넣는다면 CPU에 필요한 대부분의 데이터를 빠르게 얻어올 수 있겠지만, 캐시메모리는 용량이 적기 때문에 작업 집합의 일부만을 적재할 수 있음.

따라서 캐시 메모리의 성공 여부는 **참조의 지역성 (Locality of reference)** 원리에 달려있음

지역성은 짧은 시간동안 제한된 주소 공간의 일부만 참조되는 경향을 말함.

#### 지역성의 종류

- 시간 지역성

  for나 while 같은 반복문에 사용하는 조건 변수처럼 한번 참조된 데이터는 잠시 후 또 참조될 가능성이 높음

- 공간 지역성

  A[0], A[1]과 같은 연속 접근 시, 참조된 데이터 근처에 있는 데이터가 잠시 후 또 사용될 가능성이 높음

- 순차 지역성

  분기가 발생하지 않는 한 명령어는 메모리에 저장된 순서대로 인출/실행됨

=> 캐시에 데이터를 저장할 때는, 이러한 참조 지역성(공간)을 최대한 활용하기 위해 해당 데이터뿐만 아니라, 옆 주소의 데이터도 같이 가져와 미래에 쓰일 것을 대비함.



### 캐시 미스 경우 3가지

#### 1. Cold miss

​	해당 메모리 주소를 처음 불러서 나는 미스

#### 2. Conflict miss

​	캐시 메모리에 A와 B 데이터를 저장해야하는데, A와 B가 같은 캐시 메모리 주소에 할당되어있어서 나는 미스
​	(direct mapped cache에서 많이 발생)

> ```text
> 항상 핸드폰과 열쇠를 오른쪽 주머니에 넣고 다니는데, 잠깐 친구가 준 물건을 받느라 손에 들고 있던 핸드폰을 가방에 넣었음. 그 이후 핸드폰을 찾으려 오른쪽 주머니에서 찾는데 없는 상황
> ```

#### 3. Capacity miss

​	캐시 메모리의 공간이 부족해서 나는 미스 (Conflict는 주소 할당 문제, Capacity는 공간 문제)

-> 캐시 크기를 키워서 문제를 해결하려면, 캐시 접근 속도가 느려지고 파워를 많이 먹는 단점이 생김



### 캐시 메모리의 매핑 프로세스

매핑 프로세스는 주기억장치로부터 캐시 메모리로 데이터를 전송하는 방법을 말함.

#### 1. 직접 맵핑 (Direct Mapping)

- 가장 기본적인 구조로, DRAM의 여러 주소가 캐시 메모리의 한 주소에 대응되는 **다대일 방식**
- 주기억장치의 블록들이 지정된 한개의 캐시 라인으로만 사상될 수 있는 매핑 방법

![img](https://file.namu.moe/file/8bc9e381797334eb33da66e3ba501be191171b1c5abb113ab52fed45a20084b1c8d2eb5a0ba399d67b38a9d5990b5d5a)

그림에서는 메모리 공간이 32개(00000 ~ 11111)이고, 캐시 메모리 공간은 8개(000~111인 상황)

ex) 00000, 01000, 10000, 11000인 메모리 주소는 000 캐시 메모리 주소에 맵핑

이 때 000이 '인덱스 필드', 인덱스를 제외한 앞의 나머지(00, 01, 10, 11)를 '태그 필드'라고 함

이처럼 캐시 메모리는  `인덱스 필드 + 태그 필드 + 데이터 필드`로 구성

- 간단하고 빠르고 비용이 적게드는 장점이 있지만, **Conflict Miss가 발생하는 것이 단점**. 위 그림처럼 같은 색깔의 데이터를 동시에 사용해야할 때 발생



#### 2. 어소시에이티브 매핑 (Associative Mapping)

- 직접 매핑 방식의 단점을 보완한 방식
- 비어있는 캐시 메모리가 있으면, 마음대로 주소를 저장하는 방식
- 모든 태그들을 병렬로 검사하기 때문에 복잡하고 비용이 높다는 단점이 있어 거의 사용하지 않음

#### 3. 세트-어소시에이티브 매핑 (Set-Associative Mapping)

- 직접 매핑과 연관 매핑의 장점만을 취한 방식
- 특정 행을 지정하고, 그 행안의 어떤 열이든 비어있을 때 저장하는 방식
- 직접 매핑에 비해 검색 속도는 느리지만, 저장이 빠르고 연관 매핑에 비해 저장이 느린 대신 검색이 빠른 중간형



### 캐시 메모리의 기본 구성과 동작

CPU는 데이터를 요청할 때마다 캐시 메모리에서 해당 데이터의 존재여부를 확인함
따라서 캐시 메모리는 요청받은 데이터를 탐색하는 기능이 필요
캐시 메모리는 데이터를 관리하기 위해 **데이터 메모리와 태그 메모리**를 사용

- 블록: 데이터의 기본 단위인 워드의 집합

- 데이터 메모리 : 메모리의 데이터들이 저장된 블록으로 구성

- 태그 메모리 : 데이터 메모리의 블록을 탐색할 정보를 포함

  태그 메모리의 엔트리는 데이터 메모리 블록과 쌍을 이루면서 태그, 유효 비트, 갱신 비트를 포함. 또한 CPU 주소와 태그를 비교하는 비교기를 가지고 있음

  - 태그(tag) : CPU가 요청한 데이터를 탐색하는데 사용할 주소의 일부. 캐시 블록 주소에서 인덱스로 사용되지 않는 부분
  - 유효 비트(valid bit) : 캐시 블록이 유효한 데이터인지 나타냄
  - 갱싱 비트(dirty bit) : 캐시로 블록을 가져온 후 CPU가 블록을 수정했는지 나타냄

##### 기본적인 동작의 흐름

- CPU가 캐시에 주소 전송 > 태그 메모리 탐색 > 일치하는 태그 발견 (hit) > 블록 상태 갱신(필요할 경우) >데이터 메모리에서 블록 추출 > 요청받은 데이터 선택 > 캐시가 CPU에 데이터 전송
- CPU가 캐시에 주소 전송 > 태그 메모리 탐색 > 일치하는 태그 없음(miss) > 주소를 메모리로 전송해 대응하는 블록을 캐시에 저장 > 요청받은 데이터 선택 > 캐시가 CPU에 데이터 전송




---
[참조 1] : <https://coding-factory.tistory.com/357>

[참조 2] : <https://gyoogle.dev/blog/computer-science/computer-architecture/%EC%BA%90%EC%8B%9C%20%EB%A9%94%EB%AA%A8%EB%A6%AC.html>

[참조 3] : <https://zion830.tistory.com/46>




