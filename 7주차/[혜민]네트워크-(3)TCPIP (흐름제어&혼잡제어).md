# 7주차 CS 발표

## TCP/IP (흐름제어/혼잡제어)

### TCP 통신

- 일반적으로 TCP와 IP를 함께 사용하는데, IP가 데이터의 배달을 처리한다면 TCP는 패킷을 추적 및 관리함
- 신뢰성있는 데이터 전송을 지원하는 연결 지향형 프로토콜
- **흐름제어, 혼잡제어, 오류제어를 통해 신뢰성을 보장**. 그러나 이때문에 UDP보다 전송 속도가 느리다는 단점이 있음
- 데이터의 전송 순서를 보장하며 수신 여부를 확인할 수 있음



### 흐름 제어 (Flow Control)

- 송신측과 수신측 사이의 데이터 처리 속도 차이(흐름)을 해결하기 위한 기법

- 만약, `송신측의 전송량 > 수진측의 수신량 ` 일 경우 전송된 패킷은 수신측의 큐를 넘어서 손실될 수 있고, 만약 손실된다면 불필요한 응답과 데이터 전송이 송/수신측 간에 빈번히 발생하기 때문에 송신측의 패킷 전송량을 제어해야함

  > **패킷(Packet)이란?**
  >
  > 인터넷 내에서 데이터를 보내기 위한 경로 배정(라우팅)을 효율적으로 하기 위해서 데이터를 여러개의 조각으로 나누어 전송을 하는데, 이 조각을 패킷이라고 함

- 해결방법

  1) Stop and Wait

  2) Sliding Window

#### Stop and Wait

- 매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법

- 비효율적이라는 단점이 있음

![img](https://camo.githubusercontent.com/cb7f08015fa52f106d69a4cab2c4ad48129e2b71133e368808c51578c01f5437/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323633423744344535373135454345423332)



#### Sliding Window

- 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인 응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 기법

- 윈도우

  - 송신, 수신 스테이션 양쪽에서 만들어진 버퍼의 크기
  - TCP/IP를 사용하는 모든 호스트들은 실제 데이터를 보내기 전에 '3-way handshaking'을 통해 수신 호스트의 receive window size에 자신의 send window size를 맞추게 됨 

- Stop and Wait의 비효율성을 개선한 기법

- 송신측에서는 ACK 프레임을 수신하지 않더라도 여러 개의 프레임을 연속적으로 전송할 수 있음

- 목적 : 전송은 되었지만, acked를 받지 못한 byte의 숫자를 파악하기 위해 사용하는 프로토콜

- 동작 방식 

  - 먼저 윈도우에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전달이 확인되는대로 윈도우를 옆으로 옮김으로써 그 다음 패킷들을 전송

  - ![img](https://t1.daumcdn.net/cfile/tistory/253F7E485715ED5F27)
    - 송신측에서 [0,1,2,3,4,5,6]을 보낼 수 있는 프레임을 가지고 있고, 데이터 0,1을 전송했다고 가정하면 슬라이딩 윈도우 구조는  [2,3,4,5,6] 처럼 변하게 됨
    - 이때, 만약 수신측으로부터 ACK라는 프레임을 받게된다면 송신측은 이전에 보낸 데이터 0,1을 수신측에서 정상적으로 받았음을 알게 되고, 송신측의 슬라이딩 윈도우는 ACK 프레임에 따른 프레임의 수만큼 오른쪽으로 경계가 확장됨

    

### 혼잡 제어 (Congestion Control)

- 송신측의 데이터 전달과 네트워크의 데이터 처리 속도를 해결하기 위한 기법

- 한 라우터에게 데이터가 몰려 모든 데이터를 처리할 수 없는 경우, 호스트들은 재전송을 하게 되고 결국 혼잡만 가중시켜 오버플로우나 데이터 손실이 발생

- 이러한 **네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도를 제어**하는 것이 혼잡 제어의 개념

- 또한 네트워크 내에 패킷의 수가 과도하게 증가하는 현상을 혼잡이라 하며, 혼잡 현상을 방지하거나 제거하는 기능을 **혼잡제어**라고 함

- 흐름제어가 송신측과 수신측 사이의 전송속도를 다루는데 반해, 혼잡제어는 호스트와 라우터를 포함한 보다 넓은 관점에서 전송 문제를 다루게 됨

- 해결 방법

  ![img](https://t1.daumcdn.net/cfile/tistory/256E39425715F10103)

  - AIMD
  - Slow Start
  - Fast Retransmit
  - Fast Recovery



#### AIMD (Addictive Increase / Multiplicative Decrease)

- 합증가 / 곱 감소 알고리즘이라고 함
- 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 Window 크기 (단위 시간 내에 보내는 패킷의 수)를 1씩 증가시켜가며 전송하는 방법. 만약 패킷 전송에 실패하거나 TIME_OUT이 발생하면 Window 크기나 패킷의 전송 속도를 절반으로 줄임
- 이 방식은 공평한 방식임. 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만, 시간이 흐르면 평형 상태로 수렴하게 되는 특징이 있음
- 문제점은 초기 네트워크의 높은 대역폭을 사용하지 못하여 오랜 시간이 걸리게 되고, 네트워크가 혼잡해지는 상황을 미리 감지하지 못함. 즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식임



#### Slow Start (느린 시작)

- AIMD 방식이 네트워크 수용량 주변에서는 효율적으로 동작하지만, 처음에 전송 속도를 올리는데 시간이 너무 길다는 단점이 있음
- AIMD와 마찬가지로 패킷을 하나씩 보내는 것부터 시작. 이 방식은 패킷이 문제없이 도착하면 각각의 ACK 패킷마다 window size를 1씩 늘려줌. 즉, 한 주기가 지나면 window size가 2배로 됨
- 전송속도는 AIMD에 반해 지수 함수 꼴로 증가함. 대신에 혼잡 현상이 발생하면 window size를 1로 떨어뜨리게 됨
- 처음에는 네트워크의 수용량을 예상할 수 있는 정보가 없지만, 한번 혼잡 현상이 발생하고 나면 네트워크 수용량을 어느정도 예상할 수 있음
- 그러므로 혼잡 현상이 발생하였던 window size의 절반까지는 이전처럼 지수 함수꼴로 window size를 증가시키고 그 이후부터는 완만하게 1씩 증가시킴

![img](https://blog.kakaocdn.net/dn/3HTVj/btqJlsUPCno/uKH303wx8XNrmCzPOmrtqk/img.png)

- cwnd
  - 혼잡 윈도우 크기. 
  - 연결 초기에 cwnd = 1로 셋팅
  - 최대값이 될 때까지 cwnd를 1씩 증가시킴
  - 비록 윈도우 크기 cwnd는 1씩 증가하나, 각각의 확인응답되는 세그먼트마다 윈도우 크기가 1씩 증가하므로, 실제 전송되는 세그먼트 수는 지수적으로 증가함. 즉, 전송되는 세그먼트 수는 1,2,4,8,16,... 배수로 지수적으로 증가
- 미리 정해진 임계값(threshold)에 도달할 때까지 윈도우 크기를 2배씩 증가시킴
- 전송되는 데이터의 크기가 임계 값에 도달하면 혼잡 회피 단계로 넘어감

##### 혼잡 회피 (Congestion Avoidance)

- 윈도우의 크기가 임계값에 도달한 이후에는 데이터의 손실이 발생할 확률이 높음

- 따라서 이를 회피하기 위해 윈도우 크기를 선형적으로 1씩 증가시키는 방법

- 수신측으로부터 일정 시간동안 ACK를 수신하지 못하는 경우

  - 타임 아웃의 발생 : 네트워크 혼잡이 발생했다고 인식

  - 혼잡 상태로 인식된 경우

    - 윈도우의 크기 세그먼트의 수를 1씩 감소시킴
    - 동시에 임계값을 패킷 손실이 발생했을 때의 윈도우 크기의 절반으로 줄임

    <img src="https://blog.kakaocdn.net/dn/blF3bg/btqJrxU3OD0/qvOhv5cJNsLuiuglXuuoo1/img.png" alt="img" style="zoom:30%;" />



#### Fast Retransmit (빠른 재전송)

- 빠른 재전송은 TCP의 혼잡 조절에 추가된 정책
- 패킷을 받는 쪽에서 먼저 도착해야할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보내게 됨
- 단, 순서대로 잘 도착한 마지막 패킷의 다음 패킷 순번을 ACK 패킷에 실어서 보내게 되므로, 중간에 하나가 손실되면 송신측에서는 순번이 중복된 ACK 패킷을 받게 됨. 이것을 감지하는 순간 문제가 되는 순번의 패킷을 재전송 해줄 수 있음
- 중복된 순번의 패킷을 3개(3 ACK) 받으면 재전송 하게 됨. 약간 혼잡한 상황이 일어난 것으로 간주하여 window size를 절반으로 줄이게 됨



#### Fast Recovery (빠른 회복)

- 혼잡한 상태가 되면 window size를 1로 줄이지 않고 절반으로 줄이고 선형 증가시키는 방법
- 빠른 회복 정책까지 적용하면 혼잡 상황을 한번 겪고 나서부터는 순수한 AIMD 방식으로 동작하게 됨



---

[참고 1] : <https://rok93.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-TCP-%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4>

[참고 2] : <https://gyoogle.dev/blog/computer-science/network/%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4%20&%20%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4.html>


