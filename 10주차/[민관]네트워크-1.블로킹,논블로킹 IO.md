### Blocking I/O Model

- cpu의 기본적인 I/O 모델로 리눅스에서 모든 소켓 통신은 기본 blocking으로 동작
- I/O 작업이 진행되는 동안 유저 프로세스는 자신의 작업을 중단한 채 대기하는 방식

![image](https://user-images.githubusercontent.com/44665707/156510367-50d0ccac-ae55-42fe-bc81-23955ff681bb.png)

```
1. 유저는 커널에게 READ 작업 요청
2. 데이터가 입력될 때 까지 대기
3. 데이터가 입력되면 유저에게 커널이 결과를 전달
```



### Non-Blocking Model

- I/O 작업이 진행되는 동안 유저 프로세스의 작업을 중단시키지 않는 방식

![image](https://user-images.githubusercontent.com/44665707/156510487-cb18e5f9-fb7c-4049-bbb9-363c85ed12c8.png)

```
1. 유저가 커널에게 READ 작업 요청
2. 데이터가 입력 유무 상관없이 요청하는 순간 바로 결과가 반환, 입력 데이터가 없으면 결과 메시지 반환
3. 입력 데이터가 있다면 1-2번 반복
4. 커널이 유저에게 결과 전달

```

- I/O 진행시간과 관계없이 어플리케이션에서 작업을 오랜 시간 중지하지 않고 I/O 작업 진행 가능
- 반복적으로 시스템 호출이 발생해 자원 낭비 발생