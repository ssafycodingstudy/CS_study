## Blocking I/O & Non-Blocking I/O

#### I/O 작업

I/O 작업은 User level에서 직접 수행할 수 없고, Kernel level에서만 수행

따라서, 유저 프로세스(스레드)는 커널에게 I/O 작업을 요청하고 작업 완료 후 커널이 반환하는 결과를 기다림

네트워크에서의 I/O 작업은 소켓의 read/send를 생각



### 1. Blocking I/O

> I/O 작업이 진행되는 동안 유저 프로세스는 자신의 작업을 중단한 채 대기하는 방식

![img](https://media.vlpt.us/images/hammii/post/b9cacc20-ecf3-47c9-973e-b409e12ed341/image.png)

**진행 순서**

1. 유저가 커널에게 read 작업 요청
2. 데이터가 입력될 때까지 대기
3. 데이터가 입력되면 커널 모드에서 유저모드로 데이터 복사

**특징**

- I/O 작업이 진행되는 동안 유저 프로세스는 **자신의 작업을 중단한 채 대기**
- 어플리케이션에서 다른 작업을 수행하지 못하고 대기하므로 **자원 낭비**



### 2. Non-Blocking I/O

> I/O 작업이 진행되는 동안 유저 프로세스의 작업을 중단시키지 않는 방식

![img](https://user-images.githubusercontent.com/41428527/51266324-4e721e00-19fe-11e9-900a-809ff39e40c1.png)

**진행 순서**

1. 유저가 커널에게 read 작업 요청
2. 요청하는 그 순간, 바로 결과 반환
   입력 데이터가 없으면 입력 데이터가 없다는 결과 메시지(EWOULDBLOCK) 반환
3. 입력 데이터가 있을 때 까지 1-2번 반복
4. 입력 데이터가 있으면 커널 모드에서 유저모드로 데이터 복사

**특징**

- I/O 진행시간과 관계가 없기 때문에 어플리케이션에서 **작업을 중지하지 않고도 I/O 작업을 진행 가능**
- 반복적으로 시스템 호출이 발생하기 때문에 **자원 낭비**



## 키의 개념 및 종류

키는 데이터 베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 떄 다른 튜플과 구별할 수 있는 유일한 기준이 되는 속성

최소성 : 키를 구성하는 속성들 중 꼭 필요한 속성들로만 키를 구성하는 성질

유일성 : 하나의 키 값으로 튜플을 유일하게 식별할 수 있는 성질

![](http://wiki.hash.kr/images/2/25/%ED%8A%9C%ED%94%8C.PNG)

#### 후보키

- 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별할 수 있는 속성들의 부분집합을 의미ㅣ

- 모든 릴레이션은 반드시 하나 이상의 후보키 필요

- 모든 튜플에 대해서 유일성과 최소성을 만족해야함

#### 기본키

- 후보키 중에 주키

- 특정 튜플을 유일하게 구별할 수 있는 속성

- 널 값을 가질 수 없음(개체 무결성 조건)

- 동일한 값이 중복되어 저장될 수 없음(개체 무결성 조건)

#### 대체키

- 후보키가 둘 이상일 때 기본키를 제외한 나머지 키

#### 슈퍼키

- 슈퍼키는 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키

- 유일성은 만족하지만 최소성은 만족시키지 못함

#### 외래키

- 관계를 맺고 있는 릴레이션 r1과 r2에서 r1이 참조하고 있는 릴레이션 r2의 기본키와 같은 r1릴레이션 속성

- 참조되는 릴레이션의 기본키와 대응되어 릴레이션 간에 참조 관계를 표현하는데 중요한 도구

- 외래키가 되면 참조테이블 기본키에 없는 값은 입력할 수 없음(참조 무결성)

