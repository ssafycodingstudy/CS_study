## 시스템 콜(System Call)

- 응용프로그램에서 운영체제에게 어떠한 기능을 수행해 달라고 하는 하나의 수단

- 운영체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근 하기 위 한 인터페이스

#### 시스템콜의 기능

- 사용자 모드에 있는 응용 프로그램이 커널의 기능을 사용할 수 있도록 함

- 시스템 콜을 사용하면 사용자 모드에서 커널 모드로 바뀜

- 커널에서 시스템 콜을 처리하면 커널 모드에서 사용자 모드로 돌아가 작업을 계속함

#### 시스템 콜의 종류

- 프로세스 컨트롤

- 프로세스 생성 및 종료

- 메모리에 로드, 실행

- 프로세스 속성 값 확인, 지정

- wait이벤트, signal 이벤트

- 메모리 할당

##### 파일 관리

- 파일 생성, 파일 삭제

- 열기, 닫기

- 읽기, 쓰기, Reposition

- 파일 속성 값 확인, 지정

##### 장치관리

- 장치 요청 및 해제

- 읽기, 쓰기, Reposition

- 장치 속성 확인, 지정

- 비 물리적 디바이스 해제 및 장착

##### 정보 관리

- 시간 확인, 시간 지정

- 시스템 데이터 확인, 지정

- 프로세스, 파일 장치 속성 가져오기 설정하기

##### 커뮤니케이션

- 커뮤니케이션 연결 생성 및 삭제

- 메시지 송신, 수신

- 상태 정보 전달

- remote 디바이스 해제 및 장착

##### 보안 

- permission 획득

- permission 설정

## Process Control Block 

- 특정한 프로세스를 관리할 필요가 있는 정보를 포함하는, 운영체제 커널 자료구조

- 프로세스의 상태 정보를 저장한 구조체 

- 기존에 작업하던 프로세스를 어딘가 임시저장하는 공간

#### PCB에 저장되어 있는 정보

1. 프로세스 식별자(Process ID)

2. 프로세스 상태(Process state) : 생성, 준비, 실행, 대기, 완료

3. 프로그램 계수기 (Process Counter): 프로그램 계수기는 이 프로세스가 다음에 실행할 명령어의 주소를 가리킴

4. CPU 레지스터 및 일반 레지스터

5. CPU 스케줄링 정보 : 우선 순위, 최종 실행 시각, CPU 점유 시간

6. 메모리 관리 정보 : 해당 프로세스의 주소 공간

7. 프로세스 계정 정보 : 페이지 테이블, 스케줄링 큐 포인터, 소유자, 부모 등

8. 입출력 상태 정보 : 프로세스에 할당된 입출력장치 목록, 열린 파일 목록 등

9. 포인터 : 부모프로세스에 대한 포인터, 메모리 주소에 대한 포인터 등

## Context Switching

- CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB에서 읽어 레지스터에 적재하는 과정
  - 즉 프로세스가 준비 -> 실행, 실행 -> 준비, 실행 -> 대기

#### Context Switching의 OverHead

- 프로세스 작업 중에는 OverHead를 감수해야하는 순간이 있음.

- 프로세스를 수행하다가 입출력 이벤트가 발생해서 대기 상태로 전환

- 이때, CPU를 그냥 놀게 놔두는 것보다 다른 프로세스를 수행시키는 것이 효율적

- CPU를 계속 활용하기 위해 다른 프로세스를 실행시키고 Context Switching  하는 것

## IPC(Inter Process Communication) 

- 프로세스 간 통신

- 프로세스들 사이에 서로 데이터를 주고 받는 방법

- 커널이 제공하는 IPC 설비를 이용해 프로세스 간 통신을 할 수 있게 됨

#### IPC의 2가지 표준

- SYSTEM V IPC - 오래됨 호환성이 확+실하게 보장 

- POSIX IPC - 직관적인 API, 사용하기 쉬움

##### PIPE(익명 PIPE)

![](https://t1.daumcdn.net/cfile/tistory/247CBC4357187A3411)

- 한쪽방향으로만 통신이 가능함(반이중 통신)

- 양쪽 모두 송/수신을 하고 싶으면 2개의 파이프를 만들어야 함

- 전 이중통신을 구현해야 할 경우 구현이 복잡함

##### Name PIPE(FIFO)

- 부모 프로세스와 무관하게 전혀 다른 모든 프로세스 사이에서 통신이 가능함

- 읽기/쓰기가 동시에 가능하지 않음. 전 이중 통신을 위해서는 익명 파이프처럼 2개를 만들어야 

##### Message Queue

- Named PIPE의 방식과 동일하지만 다른점은 메모리 공간이라는 점

- 사용할 데이터에 번호를 붙이면서 여러 프로세스가 동시에 데이터를 쉽게 다룰 수 있음

##### Shared Memory

- 공유 메모리가 데이터 자체를 공유하도록 지원하는 설비

- 프로세스 간 메모리 영역을 공유해서 사용할 수 있도록 허용

- IPC중 가장 빠름

##### Memory Map

- 열린 파일을 메모리에 맵핑시켜서 공유하는 방식

##### Socket

- 프로세스와 시스템의 기초적인 부분, 프로세스 들 사이의 통신을 가능하게 함

- 네트워크 소켓 통신을 통해 데이터를 공유

- 클라이언트와 서버가 소켓을 통해서 통신하는 구조, 원격에서 프로세스 간 데이터를 공유할 때 사용함.

##### Semaphore

- 다른 IPC설비와는 다르게 프로세스 간 데이터를 동기화 하고 보호하는데 그 목적을 둠

- 한번에 하나의 프로세스만 접근 가능하도록 만들어줘야 할 때 사용되는 것

## CPU 스케줄링

메모리에 올라온 프로세스 중 어떤 프로세스를 먼저 처리할지 순서를 정하는 것.

#### 목적

1. 공평성 : 모든 프로세스가 자원을 공평하게 배정

2. 효율성 : 시스템 자원을 놀리는 시간 없이 스케줄링해야 함.

3. 안정성 : 우선 순위를 사용하여 중요한 프로세스가 먼저 처리되도록 해야 함.

4. 반응 시간 보장 : 응답이 없는 경우 사용자는 시스템이 멈춘 것으로 가정하기 때문에 적절한 시간안에 프로세스 요구에 반응해야 함.

5. 무한 연기 방지 : 특정 프로세스의 작업이 무한히 연기되어서는 안됨

#### 프로세스의 상태 전이

- 승인 : 프로세스 생성이 가능하여 승인됨.

- 스케줄러 디스패치 : 준비 상태에 있는 프로세스 중 하나를 선택하여 실행시키는 것

  - Context Switching

  - 사용자 모드 전환

  - 프로그램을 다시 시작하기 위해 사용자 프로그램을 적절한 위치로 이동

- 인터럽트 : 예외, 입출력, 이벤트 등이 발생하여 현재 실행 중인 프로세스를 준비 상태로 바꾸고, 해당 작업을 먼저 처리

- 입출력 또는 이벤트 대기 : 실행 중인 프로세스가 입출력이나 이벤트를 처리해아 하는 경우, 입출력/이벤트가 모두 끝날 때까지 대기 상태로 만드는 것.

#### 스케줄러가 동작하는 상황

1. 한 프로세스가 실행상태에서 대기 상태로 전환될 때
   - I/O 요청에 의한 대기

2. 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때
   - 할당된 시간이 다 끝났을 떄

3. 프로세스가 대기 상태에서 준비완료 상태로 전환될 때
   - I/O 종료 시

4. 프로세스가 종료될 때

#### 선점 및 비선점

##### 비선점

- 1,4번 같이 프로세스가 자발적으로 CPU를 반납하는 경우

- 비선점 스케줄링에서는, 일단 CPU가 한 프로세스에게 할당되면 프로세스가 종료되든지, 또는 대기 상태로 전환

##### 선점

- 2, 3번 같이 강제적으로 CPU를 빼앗기는 경우

#### 스케줄링 기준

##### CPU 스케줄링 알고리즘 비교 기준

- CPU 이용률 (utilization)
  - 전체 시스템 기간 중 CPU가 작업을 처리하는 시간의 비율

- 처리량(throughput)
  - 단위 시간당 완료된 프로세스의 개수

- 총처리 시간(turnaround time)

  - 프로세스가 시작해서 끝날 때까지 걸리는 시간

  - 대기시간 + CPU에서 실행하는 시간 + I/O 시간을 합한 시간

- 대기시간(waiting time)
  - 프로세스가 준비 큐에서 대기하면서 보낸시간의 합

- 응답시간(responswe time)
  - 제출 후 첫 응답이 시작하는데까지 걸리는 시간이다.

#### 스케줄링 알고리즘

##### 비선점 알고리즘

##### 선입 선처리(First-come, First-Served)

- CPU를 먼저 요청하는 순으로 할당받는다.

##### 최단 작업 우선 스케줄링(Shortest Job First)

- 가장 작은 CPU버스트 시간을 가진 프로세스에게 우선적으로  CPU할당

- CPU버스트가 같다면 선입 선처리 스케줄링 적용

- 선점이거나 비선점 알고리즘이다.

![SJF](https://media.vlpt.us/images/mu1616/post/11035f72-bd7d-40ae-89b6-4375f70234a0/image.png)

![선점SJF](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FefLX2P%2FbtqApj5XYCI%2FkutI2dU1g03xdQWLfkSEY1%2Fimg.png)

##### HRN(Hightest Response-ratio Next)

- 우선순위를 계산하여 점유 불평등을 보완한 방법

- 우선순위 = (대기시간 + 실행시간)/ 실행시간

| 작업 | 실행시간 | 대기시간 |
| ---- | -------- | -------- |
| A    | 18       | 10       |
| B    | 24       | 16       |
| C    | 19       | 8        |

- A = (10 + 18)/18 = 1.56

- B = (24 + 16)/24 = 1.67

- C = (19 + 8)/19 = 1.42

###### B > A > C 순서로 실행

#### 선점 스케줄링

##### 우선순위 스케줄링(Priority Scheduling)

- 우선순위를 부여하여 우선순위가 높은 순으로 처리

- 우선 순위가 낮은 프로세스가 무한정 기다리는 Starvation이 생김

- aging기법으로 문제해결가능
  - aging - 정해진 시간마다 대기 중인 프로세스의 우선 순위를 1씩 증가시킴

![우선순위](https://t1.daumcdn.net/cfile/tistory/992EAA335A27D1CF2E)

##### 라운드 로빈 스케줄링(Round-Robin)

- 각 프로세스는 시간 할당량 만큼 CPU를 할당받는다.

- 준비큐는 원형큐 형태로 동작한다.

- Context Switching이 자주 일어난다. - 오버헤드 발생

![RR](https://upload.wikimedia.org/wikipedia/commons/7/76/Round_Robin_Schedule_Example.jpg)

##### Multilevel Queue(다단계 큐)

- 작업들을 여러 종류의 그룹으로 나누어 여러개의 큐를 이용하는 기법

- 우선순위가 낮은 큐들이 실행 못하는걸 방지하고자 각 큐마다 다른 시간 할당량을 설정

- 우선순위가 높으면 적은 할당량 많으면 낮은 할당량

| 시스템 프로세스 큐      | 우선순위 높음 |
| ----------------------- | ------------- |
| 대화형 프로세스큐       |               |
| 대화형 편집 프로세스 큐 |               |
| 일괄처리 프로세스 큐    |               |
| 학생 프로세스 큐        | 우선순위 낮음 |

![](https://user-images.githubusercontent.com/13609011/91695428-16a2f480-eba9-11ea-8d91-17d22bab01e5.png)

- 우선순위가 높은 큐가 비어있지 않으면 하위 큐에 프로세스는 실행될 수 없다.

- 큐들 사이에 시간을 나눠쓴다. 

- 포그라운드 큐( 백 그라운드 큐보다 절대적으로 우선순위가 높음)와 백그라운드 큐의 예에서 CPU시간을 할당받아서 포그라운드는 RR알고리즘 백그라운드는 FCFS 알고리즘으로 처리

##### 다단계 피드백 큐

- 영구적으로 하나의 큐에 할당된다.

- 다음의 매개변수에 의해서 결정

  - 큐의 개수

  - 각 큐를 위한 스케줄링 알고리즘

  - 한 프로세스를 높은 우선순위 큐로 올려주는 시기를 결정하는 방법

  - 한 프로세스를 낮은 우선순위 큐로 강등시키는 시기를 결정하는 방법

  - 프로세스가서비스를 필요로 할 때 프로세스가 들어갈 큐를 결정하는 방법

![](https://user-images.githubusercontent.com/13609011/91695489-2cb0b500-eba9-11ea-8578-6602fee742ed.png)

그외

스레드 스케줄링

Pthread 스케줄링

[참조]

https://jhnyang.tistory.com/33

https://www.joinc.co.kr/w/Site/system_programing/Book_LSP/ch08_IPC

https://jwprogramming.tistory.com/541

https://velog.io/@mu1616/CPU-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81