# 4주차 CS 발표

## CPU Scheduling

### 프로세스 스케줄링

 CPU 스케줄러는 프로세스가 생성된 후 종료될 때까지 모든 상태 변화를 조정하는 일을 함

이 스케줄러가 하는 CPU 스케줄링은 어떤 프로세스에 CPU를 배정할 지 결정하고, 이 작업은 컴퓨터 시스템의 효율에 직결되는 중요한 일임.

CPU 스케줄링의 본 목적은 모든 프로세스가 공평하게 작업할 수 있도록 하는 것. 하지만 안정성과 효율성을 높이기위해 공평성의 일부분을 희생해야함.

- 목표
  - Batch System : 가능하면 많은 일을 수행. 시간(time)보다 처리량(throughout)이 중요
  - Interactive System : 바른 응답시간, 적은 대기시간
  - Real-time System : 기한(deadline) 맞추기



### 프로세스 상태와 상태전이

![img](https://media.vlpt.us/images/dasssseul/post/7fcb1c75-9954-48b6-8a82-cd51e723b4b9/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-15%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%201.49.02.png)



#### 프로세스 상태

1. 생성
   - 사용자에 의해 프로세스가 생성된 상태
2. 준비
   - CPU를 할당받을 수 있는 상태
   - 가장 높은 우선순위를 갖는 프로세스가 다음 순서에 CPU를 할당 받음
3. 실행
   - CPU를 할당받아 동작(점유)중인 상태
4. 대기
   - 프로세스 실행 중 입출력(I/O) 처리 등으로 CPU를 양도하고 처리 완료까지 기다리는 상태
   - 대기 리스트는 우선 순위가 존재하지 않음
5. 종료
   - 프로세스가 CPU를 할당받아 주어진 주어진 시간 내에 완전히 수행을 종료한 상태



#### 프로세스 상태 전이

- 디스패치(Dispatch)
  - `준비 상태 → 실행 상태`
  - 준비 리스트에 있는 여러 프로세스 중 실행될 프로세스를 선정하여 CPU를 할당
- 타이머 런 아웃(Timer Run Out)
  - `실행 상태 → 준비 상태`
  - 지정된 시간이 초과되면 CPU 반납 후 다시 준비 상태로 전이
- 블록(Block) 
  - `실행 상태 → 대기 상태`
  - 지정된 할당 시간을 초과하기 전 입출력 또는 기타 사건이 발생하면 입출력이 완료될 때까지 대기 상태로 전이
- 웨이크업(Wake-up)
  - `대기 상태 → 준비 상태`
  - 어느 순간 입출력이 종료되면 대기 상태의 프로세스에게 입출력 종료 사실을 알려주고 준비 상태로 전이

> 어느 시점에서 CPU를 점유하고 있는 프로세스는 단 한 개이고, 여러개의 프로세스를 번갈아 가면서 실행함.



### 프로세스 스케줄링 유형

#### 선점형(preemptive) 스케줄링 vs 비선점형 (non-preemptive) 스케줄링

- 선점형 스케줄링
  - 하나의 프로세스가 CPU를 차지하고 있을 때, `우선 순위가 높은 다른 프로세스가 현재 프로세스를 중단시키고 CPU를 점유하는 스케줄링 방식`
  - CPU 처리시간이 매우 긴 프로세스가 CPU 사용 독점을 막을 수 있어 효율적인 운영이 가능.
  - 하지만 잦은 문맥 교환으로 오버헤드가 많이 발생
  - 처리시간 예측이 어려움.
  - 종류 : 라운드 로빈, SRT, 다단계 큐, 다단계 피드백 큐
- 비선점형 스케줄링
  - 하나의 프로세스가 CPU를 할당 받으면, `작업 종료 후 CPU 반환시까지 다른 프로세스가 CPU를 점유할 수 없는 스케줄링 방식`
  - 모든 프로세스에 대한 요구를 공정하게 처리
  - 필요한 문맥 교환만 일어나기 때문에 오버헤드가 상대적으로 적지만 프로세스의 배치에 따라 효율성 차이가 많이 남.
  - 처리시간 예측 용이함.
  - 짧은 작업을 수행하는 프로세스가 긴작업 종료 시까지 대기
  - 종류 : 우선순위, 기한부, FCFS, SJF, HRN



### 프로세스 스케줄링 알고리즘

- #### 선점형 스케줄링 알고리즘

  ##### 라운드 로빈

  - 프로세스는 `같은 크기의 CPU 시간`을 할당 (균등한 CPU 점유 시간)

  - 프로세스가 할당된 시간 내에 처리 완료를 못한다면, 준비 큐 리스트의 가장 뒤로 보내지고 CPU는 대기중인 다음 프로세스로 넘어감

    ![img](https://media.vlpt.us/images/dasssseul/post/2f377263-07a1-46bb-ac05-e199241dce91/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-15%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%201.52.39.png)

  

  ##### SRT(Shortest Remaining Time First)

  - `가장 짧은 소요 시간`이 걸리는 프로세스를 먼저 수행

  - 남은 처리 시간이 더 짧다고 판단되는 프로세스가 준비 큐에 생기면 언제라도 프로세스가 선점됨

    ![img](https://media.vlpt.us/images/dasssseul/post/5640f31e-5f0e-4985-a78d-a5918eda20bf/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-15%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%201.54.40.png)

  ##### Multilevel-Queue (다단계 큐)

  - 작업들을 여러 종류의 그룹으로 나누어 여러 개의 큐를 이용하는 기법

  ![Untitled](https://user-images.githubusercontent.com/13609011/91695480-2a4e5b00-eba9-11ea-8dbf-390bf0a73c10.png)

  - 우선순위가 낮은 큐들이 실행 못하는 걸 방지하고자 각 큐마다 다른 `Time Quantum`을 설정해주는 방식 사용
  - 우선순위가 높은 큐는 작은 `Time Quantum`할당. 우선순위가 낮은 큐는 큰 `Time Quantum` 할당

  

  ##### Multilevel-Feedback-Queue (다단계 피드백 큐)

  

  ![Untitled2](https://user-images.githubusercontent.com/13609011/91695489-2cb0b500-eba9-11ea-8578-6602fee742ed.png)

  - 다단계 큐에서 자신의 `Time Quantum`을 다 채운 프로세스는 밑으로 내려가고, 자신의 `Time Quantum`을 다 채우지 못한 프로세스는 원래 큐 그대로
    - Time Quantum을 다 채운 프로세스는 CPU burst 프로세스로 판단하기 때문
  - 짧은 작업에 유리, 입출력 위주(Interrupt가 잦은) 작업에 우선권을 줌
  - 처리 시간이 짧은 프로세스를 먼저 처리하기 때문에 Turnaround 평균 시간을 줄여줌



- #### 비선점형 스케줄링 알고리즘

  ##### FCFS (First Come First Service)

  - 프로세스가 `대기 큐에 도착한 순서`에 따라 CPU 할당

  - Queue와 동일, FIFO 알고리즘

    ![img](https://media.vlpt.us/images/dasssseul/post/f46d94bc-6b84-4f77-a45f-4af507ba6b4f/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-15%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%201.55.08.png)

  

  ##### SJF(Shortest Job First)

  - 프로세스가 도착하는 시점에 따라 `그 당시 가장 짧은 소요 시간을 갖는 프로세스가 종료 시 까지 CPU 점유`

  - CPU 요구 시간이 긴 작업과 짧은 작업 간의 불평등이 심해 기아 현상 발생 가능성

    ![img](https://media.vlpt.us/images/dasssseul/post/f0619c2f-5e0c-46d5-818a-2667f083de48/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-15%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%201.55.36.png)

  ##### HRN(Hightest Response-ratio Next)

  - 우선순위를 계산하여 점유 불평등을 보완한 방법(SJF의 단점 보완)
  - 우선순위 = (대기시간 + 실행시간) / (실행시간)




### CPU 스케줄링 성능 척도

스케줄링의 효율을 분석하는 기준

- CPU utilization (CPU 이용률) : CPU가 수행되는 비율
- Throughput (처리율, jobs/sec) : 단위 시간당 처리하는 작업의 수 (처리량)
- Turnaround time (반환시간) : 실행 시간과 대기 시간을 모두 합한 시간으로 작업이 완료될 때 까지 걸린 시간. (CPU, waiting, I/O 등 모든 시간을 포함) 반환시간은 짧을 수록 좋음
- Waiting time (대기시간) : CPU를 점유하기 위해서 ready queue에서 기다린 시간을 말함. (다른 큐에서 대기한 시간은 제외)
- Response time (응답시간) : 작업이 처음 실행되기까지 걸린 시간. 일반적으로 대화형 시스템에서 입력에 대한 반응 시간을 말함.

 

---

[참고 1] : <https://bnzn2426.tistory.com/65>

[참고 2] : <https://gyoogle.dev/blog/computer-science/operating-system/CPU%20Scheduling.html>

[참고 3] : <https://velog.io/@dasssseul/CS-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%EC%84%A0%EC%A0%90-%EB%B9%84%EC%84%A0%EC%A0%90>

[참고 4] : <https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-6.-CPU-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81>


