### 메모리 관리 기법

- 메모리 관리 기법은 크게 연속 메모리 관리와 불연속 메모리 관리로 나뉨



### 연속 메모리 기법

- 프로그램 전체가 메모리에 연속적으로 할당되어야 하는 기법
- 고정 분할 기법 : 메모리가 고정된 파티션으로 분할, 내부 단편화 발생
- 동적 분할 기법 : 파티션들이 동적 생성, 자신의 크기와 같은 파티션에 적제, 외부 단편화 발생



### 불연속 메모리 관리

- 프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법
- Page : 프로세스를 고정된 크기의 작은 블록들로 나눴을 때, 그 블록들을 페이지라 함
- Frame : 페이지 크기와 같은 주 기억장치 메모리 블록
- Segment : 서로 다른 크기의 논리적 단위



### 가상 메모리

- 실제 메모리 크기와 관계 없이 메모리를 사용할 수 있또록 가상 메모리 주소를 사용하는 것
- 프로세스의 일부분만 메모리에 로드하고 나머지는 보조 기억 장치(가상 메모리 공간)에 둠
- MMU(메모리 관리 유닛)를 통해 논리 주소, 물리 주소를 나누어 사용하여 CPU를 속임

- 장점
  - 실제 메모리보다 더 큰 공간을 사용
  - 가상의 주소를 사용해 논리적인 연속성 제공
  - 물리 메모리의 주소 공간을 몰라도 됨



### 메모리 단편화(Memory Fragmentation)

- 메모리 공간이 조각조각 나뉘게 되면 실제로는 사용가능한 메모리가 충분히 존재하지만 할당이 불가능한 상태

- 내부 단편화
  - 메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당돼서 프로세스에서 아용하는 메모리 공간이 낭비
  - 어떤 프로그램 OS가 5MB 만큼 메모리를 할당했지만 실제로는 1MB 만큼의 메모리를 사용할 경우 4MB만큼 내부 단편화 발생
- 외부 단편화
  - 메모리가 할당되고 해제되는 작업이 반복적으로 일어날 때
  - 할당된 메모리와 메모리 사이에 중간중간 사용하지 않는 작은 메모리가 생김
  - 총 메모리 공간은 충분하지만 실제로는 할당할 수 없는 상황 발생



### 메모리 단편화 해결 방법

1. 페이징(Paging)
   - ![8](https://user-images.githubusercontent.com/44665707/150272623-637aeda5-ef08-4635-9066-d78961f7e4ea.PNG)
   - 프로세스는 페이지로 나뉘어지고, 물리 메모리는 프레임으로 나뉘어짐
2. 페이지 테이블에는 각 페이지 번호와 해당 페이지가 할당된 프레임의 시작 물리 주소를 저장
   - CPU는 논리 주소로 프로그램이 설정한대로 연속적인 주소값으로 명령을 내리고 이는 메모리로 가기 전에 각 페이지의 실제 메로리 주소가 저장되어 있는 테이블에서 물리 주소로 변경
   - 만약 프로세스가 프레임의 정수배보다 살짝 작다면 할당된 마지막 프레임은 전부 사용되지 않고 남아버리는 내부 단편화 발생(페이지 클수록 커짐)



2. 세그먼테이션(Segmentation)

![9](https://user-images.githubusercontent.com/44665707/150273084-7676a916-3bb5-4bbc-b957-d93edb5fe5f8.PNG)





- 
  - 사용자/프로그래머 관점의 메모리 관리 기법
  - Segment : 페이지 같은 개념이지만, 프로세스를 논리적 내용을 기반으로 나눠서 메모리에 배치
  - 프로세스를 Code, Data, Stack으로 나누는 것 역시 세그먼테이션
  - 세그먼트 테이블은 세그먼트 번호와 시작주소(base), 세그먼트 크기(limit)을 엔트리로 가짐
  - 가상 메모리 사용
  - CPU에서 해당 세그먼트의 크기 넘어서는 주소가 들어오면 인터럽트가 발생해 해당 프로세스를 강제 종료



### 페이징와 세그먼테이션 차이

1. 페이징은 고정 크기를 가짐
2. 세그먼테이션은 가변 크기를 가짐
3. 페이지은 내부 단편화 발생 가능, 세그먼테이션은 외부 단편화 발생 가능