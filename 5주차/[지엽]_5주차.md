## 교착상태 데드락

#### 데드락의 조건

4가지 모두 성립해야 데드락이 발생

- 상호배제(Mutual exclusion) - 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다.

- 점유대기(Hold and wait) - 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다림

- 비선점(No preemption) - 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없음

- 순환대기(Circular wait) - 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가짐

#### 데드락의 관리

- 데드락 예방 - 비용이 많이 드는 문제점

- 상호배제 조건의 제거 - 여러 프로세스가 공유 자원 사용

- 점유대기 조건의 제거 - 프로세스 실행전 모든 자원을 할당

- 비선점 조건의 제거 - 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납

- 순환대기 조건의 제거 - 자원에 고유번호 할당 후 순서대로 자원 요구

#### 데드락 회피

자원 할당 그래프 알고리즘

![그래프](https://t1.daumcdn.net/cfile/tistory/2745A63A5714C38329)

- 프로세스 Pi로부터 자원 Rj로의 방향 간선은 Pi ->Rj로 표현하며 이것은 프로세스 Pi가 자원 꺼을 요청하는 것으로 현재 이 자원을 기다리는 상태이다.

- 자원 Rj로부터 프로세스 Pi로의 방향 간선은 Rj->Pi로 표현하며 이것은 자원이 프로세스 Pi에 이미 할당된 것을 의미 한다.

- 자원을 요청할 때마다 탐지 알고리즘을 실행하면 그에 대한 오버헤드가 발생한다.

은행원 알고리즘

- 다익스트라가 제안한 방법으로, 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는 데서 유래

- 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지를 사전에 검사하여 교착상태를 회피하는 방법

- 안정 상태에 있으면 자원을 할당하고, 그렇지 않으면 다른 프로세스들이 자원을 해지할 때까지 대기함

- 교착 상태가 되지 않도록 보장하기 위하여 교착 상태를 예방하거나 회피하는 프로토콜을 이용하는 방법

#### 데드락 무시

예방이나 회피 기법을 프로그래밍 해서 넣으면 성능에 영향을 미침 ->  무시함

#### 데드락을 탐지 회복

- 탐지

  - 자원 할당 그래프를 통해 교착 상태 탐지

  - 자원 요청 시, 탐지 알고리즘을 실행시켜 그에 대한 오버헤드 발생함

- 회복
  - 데드락 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복시키는 방법

- 프로세스 종료방법

  - 데드락의 프로세스를 모두 중지

  - 데드락이 제거될 때까지 하나씩 프로세스 중지

- 자원 선점 방법

  - 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당

  - 우선 순위가 낮은 프로세스나 수행 횟수 적은 프로세스 위주로 프로세스 자원 선점

## 경쟁상태 Race Condition

두 개 이상의 프로세스들이 하나의 자원에 접근하기 위해 경쟁하는 상태

#### 임계영역 Critical Section 

스레드가 두개 이상 접근하면 안되는 곳

#### 경쟁 상태 해결을 위한 조건

- 상호배제(Mutual Exclusion) - 임계 영역이 수행 중이면 다른 모든 프로세스들은 그 영역에 들어가지 못하게 막는 것

- 진행(Progress) - 임계영역이 비었을 경우 임계영역에 들어가려는 프로세스가 있으면 들어가게 해줌
  - 즉 임계 영역에 있는 프로세스 외에는 다른 프로세스가 임계영역에 진입하는 것을 방지

- 한정대기(Bounded Waiting) - 기아 상태를 방지하기 위해 임계 영역에 들어가는 횟수에 한계가 있어야 한다.

#### 상호 배제 기법 

#### Lamport bakery 알고리즘

프로세스가 n 개일때

프로세스에게 고유한 번호를 부여하고 우선순위가 높은 프로세스가 먼저 임계구역에 진입하도록 구현

- 번호가 낮을수록 우선순위가 높음

```c++
while(1) {              // 프로세스i의 진입 영역

  choosing[i] = ture;   // 번호표 받을 준비
  number[i] = max(number[0], number[1], ..., number[n-1]) + 1;  // 번호표 부여 
                                                                // (번호표 부여중 선점이 되어 같은 번호를 부여 받는 프로세스가 발생할 수 있음)
  chossing[i] = false;  // 번호표를 받음

  for (j = 0; j < n; j++) { // 모드 프로세스와 번호표를 비교함.
    while (choosing[j]);    // 프로세스j가 번호표를 받을 때까지 대기

    while ((number[j] != 0) &&    
            ((number[j] < number[i])               // 프로세스 j가 프로세스 i보다 번호표가 작거나(우선순위가 높고)
            || (number[j] == number[i] && j < i)); // 또는 번호표가 같을 경우 j 가 i 보다 작다면 
                                                   // 프로세스 j가 임계구역에서 나올 때까지 대기.     
  }


// Critical Section

  number[i] = 0;  // 임계구역 사용완료를 알림.
}
```

#### 피터슨 알고리즘

프로세스가 2 개일 때 (bool 변수 2 / turn 1개)

flag는 진입할 것을 알리는 변수 turn 은 누가 들어갈 차례인지 알림

``` c++
while(1) {                        // 프로세스i의 진입 영역

  flag[i] = ture;                 // 프로세스i가 임계구역에 진입하기 위해 진입을 알림.
  turn = j;                       // 프로세스j에게 진입을 양보함.
                                  //  (두 프로세스중 먼저 양보한쪽이 먼저 임계구역에 들어가게 됨.)
  while (flag[j] && turn = j);    // 프로세스i의 차례가 될 때까지 대기를 함.

// critical section

  flag[i] = false                 // 임계구역 사용완료를 알림.

}
```



## 세마포어와 뮤텍스

여러 프로세스나 쓰레드가 공유 자원에 접근하는 것을 제어하기 위한 방법

즉, 병행 처리를 위한 프로세스 동기화 기법

#### 세마포어의 동작 원리

- 세마포어변수 - 정수 값을 가지는 변수

- semWait 연산 - 세마포어 값을 감소 시킴, 음수가 되면 호출한 프로세스는 블록.

- semSignal 연산 - 세마포어 값을 증가 시킴 양수가 아니면 연산에 의해 블록된 프로세스들을 깨움.

```jav
struct semaphore {
	int count;
    	queueType queue;
};

void semWait (semaphore s) {
	s.count--;
    if (s.count < 0) {
    	/* 이 구역으로 들어왔다는 것은 현재 프로세스(혹은 쓰레드)가 공유 자원에 접근할 수 없다는 것을 의미*/
    	/* 요청한 프로세스를 s.queue에 연결 */
        /* 요청한 프로세스를 블록 상태로 전이 시킴*/
    }
} 

void semSignal (semaphore s) {
	s.count++;
    if (s.count <= 0) {
    	/* count가 0보다 작거나 같다는 것은 대기하고 있는 프로세스(또는 스레드)가 존재한다는 것을 의미*/
        /* s.queue에 연결되어 있는 프로세스를 큐에서 제거 */
        /* 프로세스의 상태를 실행 가능으로 전이시키고 ready list에 연결 */
    }
}

const int n = /* 프로세스 개수 */;
semaphore s = 1;

void P (int i) {
	while (true) {
    	semWait(s);
        
        /* 임계 영역(Critical Section)*/
        
        semSignal(s);
        
        /* 임계 영역 이후 코드 */
    }
}

void main() {
	parbegin (P(1), P(2), ..., P(n));
}
```

#### 세마포어의 종류

- 카운팅 세마포어 - 세마포어의 초기값이 0 이상의 수

- 이진 세마포어 - 세마포어의 초기 값이 0 또는 1만 가질 수 있는 세마포어



- 강성 세마포어 - 큐에서 선입선출로 꺼내는 경우

- 약성 세마포어 - 큐에서 제거되는 순서를 명시하지 않은 경우



#### 뮤텍스 

병행 처리를 위한 동기화 기법, 1과 0으로 초기값을 가짐

임계영역에 들어갈때 락을 걸어 다른 프로세스가 접근하지 못하도록 막고 나오면 락을 해제(뮤텍스 락)

```java
mutex = 1;

void lock () {
	while (mutex != 1) {
    	/* mutex 값이 1이 될 때까지 기다립니다.*/
    }
    /* 이 구역에 도착했다는 것은 mutex 값이 1이라는 것입니다.
       따라서 이제 뮤텍스 값을 0으로 만들어 다른 프로세스(혹은 쓰레드)가 접근하지 못하도록 막아야 합니다.
    */
    mutex = 0;
}

void unlock() {
	/* 임계 구역에서 나온 프로세스는 다른 프로세스가 접근할 수 있도록 락을 해제합니다.*/
	mutex = 1;
}
```

#### 뮤텍스와 세마포어의 차이

- 세마포어는 공유 자원에 세마포어의 변수 만큼의 프로세스가 접근

- 반면 뮤텍스는 오직 1개만의 프로세스만 접근

  ------------------------------------------------------------------------------------------

- 현재 수행중인 프로세스가 아닌 다른 프로세스가 세마포어 해제

- 뮤텍스는 락을 획득한 프로세스가 반드시 락을 해제



## 메모리 관리기법

메모리 용량이 증가함에 따라 프로그램의 크기 또한 계속 증가하기 때문에 메모리는 부족

제한된 물리 메모리의 효율적인 사용과 메모리 참조 방식을 제공하는 전략



#### 효과적인 메모리 사용

##### 메모리 낭비 방지

1. 동적 적재

- 프로그램 실행에 반드시 필요한 루틴과 데이터만 적재

- 모든 루틴과 데이터는 항상 사용하지 않고, 실행 시 필요하다면 그 때 해당 부분을 메모리에 적재

2. 동적 연결

- 라이브러리 루틴 연결을 컴파일 시점에 하는 것이 아닌 실행 시점까지 미루는 기법

3. 스와핑

- CPU에서 실행중이지 않는 프로세스는 저장장치의 swap영역으로 이동해 메모리를 확보

- Context Switching으로 오버헤드가 발생할 수 있지만 메모리 공간 확보엔 효율적



#### 단편화

메모리 공간이 충분함에도 불구하고 프로세스가 메모리에 적재되지 못하는 현상

##### 외부 단편화

![외부단편화](https://trello-attachments.s3.amazonaws.com/5e8aea3aaf239f64e5fe7306/820x347/3113cb036860ef7b97257f0ca5cc9451/image.png)

- 프로세스가 적재되고 제거되는 일이 반복되면서, 여유 공간이 충분하지만 공간들이 조각으로 흩어져 있어(Scattered Holes) 메모리에 적재되지 못하는 상황

##### 내부 단편화

![내부 단편화](https://trello-attachments.s3.amazonaws.com/5e8aea3aaf239f64e5fe7306/820x393/d6b06e1de4afa891f98f931148041065/image.png)

- 고정분할 방식에서 프로세스가 실제 사용해야할 메모리보다 더 큰 메모리를 할당받아 메모리가 낭비되는 현상

##### 압축

- 외부 단편화 해소를 위해 메모리 공간을 모으는 방법

- Scattered Holes를 합치는 과정에서 메모리에 적재된 프로세스를 정지시키고 한쪽으로 이동시키는 작업 

- 비효율적이고 어느 공간을 기준으로 모을지 알고리즘이 모호함

#### 메모리 관리 전략

##### 연속 메모리 할당

프로세스를 메모리에 연속적으로 할당하는 기법

할당과 제거를 반복하다보면 Scattered Holes가 생겨나고 이로 인해 외부 단편화가 발생

연속 메모리 할당에서 외부 단편화를 줄이기 위한 할당 방식

1. 최초 적합(First Fit)

- 가장 처음 만나는 빈 메모리 공간에 프로세스를 할당, 빠름

2. 최적 적합(Best Fit)

- 빈 메모리 공간의 크기와 프로세스의 크기 차이가 가장 적은 곳에 프로세스를 할당

3. 최악 적합(Worst Fit)

- 빈 메모리 공간의 크기와 프로세스의 크기 차이가 가장 큰 곳에 프로세스를 할당

- 이렇게 생긴 빈 메모리 공간에 또 다른 프로세스를 할당 할 수 있을 거라는 가정에 기인



#### 페이징

- 메모리 공간이 연속적으로 할당되어야 한다는 제약조건을 없애는 메모리 관리 전략

- 논리 메모리는 고정 크기의 페이지, 물리 메모리 고정크기의 프레임 블록으로 나누어 관리

- 프로세스가 사용하는 공간을 논리 메모리에서 여러개의 페이지로 나누어 관리

- 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 매핑되어 저장

- Memory Management Unit의 재배치 레지스터 방식을 활용해 CPU가 마치 프로세스가 연속된 메모리에 할당된 것처럼 인식하도록함

- 내부 단편화가 발생

#### 세그멘테이션

- 페이징 기법과 반대로 논리 메모리와 물리메모리를 같은 크기의 블록이 아닌, 서로 다른 크기의 논리적 단위인 세그먼트로 분할

- 외부 단편화 발생



#### 혼용기법

- 혼용해서 단편화를 줄이는 전략

- 매핑테이블을 두번 거쳐야 하므로 속도가 느려짐



[참조]

https://jwprogramming.tistory.com/12

https://zangzangs.tistory.com/115?category=458016

https://velog.io/@conatuseus/OS-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4%EC%99%80-%EB%AE%A4%ED%85%8D%EC%8A%A4

https://dheldh77.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5Memory-Management-Strategy

https://junghyun100.github.io/%EB%A9%94%EB%AA%A8%EB%A6%AC%EB%8B%A8%ED%8E%B8%ED%99%94/