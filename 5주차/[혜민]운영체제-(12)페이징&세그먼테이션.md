# 5주차 CS 발표

## 페이징과 세그먼테이션

### 메모리 관리 기법

메모리 관리 기법은 크게 **연속 메모리 관리**와 **불연속 메모리 관리**로 나뉨

#### 연속 메모리 기법

- 프로그램 전체가 메모리에 연속적으로 할당되어야하는 관리 기법
- 고정 분할 기법 : 메모리가 고정된 파티션으로 분할, **내부 단편화 발생**
- 동적 분할 기법 : 파티션들이 동적 생성, 자신의 크기와 같은 파티션에 적재, **외부 단편화 발생**

#### 불연속 메모리 관리

- 프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법
- Page : 프로세스를 고정된 크기의 작은 블록들로 나눴을 때, 그 블록들을 페이지라고 함
- Frame : 페이지 크기와 같은 주기억장치 메모리 블록
- Segment : 서로 다른 크기의 논리적 단위



### 가상 메모리

- 실제 메모리 크기와 상관없이 메모리를 사용할 수 있도록 가상 메모리 주소를 사용하는 것
- 프로세스의 일부분만 메모리에 로드하고, 나머지는 보조기억장치(가상 메모리 공간)에 둠

#### 가상 메모리 사용의 장점

- 실제 메모리(RAM)보다 더 큰 공간 사용가능
- 가상의 주소 공간을 사용해 논리적인 연속성 제공
- 물리 메모리의 주소 공간을 알 필요가 없어짐

#### 하나의 프로세스를 여러 곳에 나눠 저장했을 때의 동작 과정

MMU를 통해 논리주소, 물리주소를 나눠 사용함으로써 CPU를 속임

> MMU : 가상 주소 → 실제 메모리 주소로 변환해주는 장치




### 가상 메모리 관리 기법

#### 1. 페이징 (Paging)

프로세스를 고정 크기인 페이지로 잘라서 메모리에 적재하는 방법

![img](https://images.velog.io/images/nnnyeong/post/55d02938-84d6-4ac4-addd-9dc195515e9c/image.png)

- 물리 메모리는 frame, 프로세스는 page라 불리는 고정 크기로 분할함

- 페이지 테이블에는 각 **페이지 번호**와 해당 페이지가 할당된 프레임의 **시작 물리 주소**를 저장

- CPU는 논리 주소로 프로그램이 설정한 대로 연속적인 주소값으로 명령을 내리고, 이는 메모리로 가기 전에 각 페이지의 실제 메모리 주소가 저장되어있는 테이블에서 물리 주소로 변경

- 만약 프로세스가 프레임의 정수배보다 살짝 작다면 할당된 마지막 프레임은 전부 사용되지 않고 남아버리는 **내부 단편화**문제가 발생 (페이지가 클수록 내부 단편화 커짐)

  > 내부 단편화 : 할당된 단위보다 적은 용량의 프로그램이 적재되어 공간이 낭비되는 것

  ![img](https://media.vlpt.us/images/dbswl31024/post/c6ae69b0-36da-439a-8258-12a40f10af6f/image.png)

#### 2. 세그먼테이션 (Segmentation)

- 프로세스를 크기가 서로 다 세그먼트로 분할해 메모리에 적재하는 방법

  ![img](https://images.velog.io/images/nnnyeong/post/e5f07c87-9e6e-4c8f-90c9-9c92920ab486/image.png)

- 사용자/프로그래머 관점의 메모리 관리 기법

- Segment : 페이지 같은 개념이지만, 프로세스를 **논리적 내용을 기반으로 나눠서** 메모리에 배치

- 프로세스를 Code, Data, Stack으로 나누는 것 역시 세그먼테이션

- 세그먼트 테이블은 **세그먼트 번호**와 **시작 주소(base)**, **세그먼트 크기(limit)**을 엔트리로 가짐

- CPU에서 해당 세그먼트의 크기를 넘어서는 주소가 들어오면 인터럽트가 발생해서 해당 프로세스를 강제 종료

- 외부 단편화 문제 발생

  > 외부 단편화 : 작업보다 많은 공간이 남아있더라도, 그 작업을 받아들이지 못하는 것
  >
  > - 아래 예시에선는 메모리 용량이 100MB가 남았지만, 실제로 C 작업이 들어갈 수 없음

  ![img](https://media.vlpt.us/images/dbswl31024/post/6672df94-3ace-4715-ac67-d39e6ffd9ddb/image.png)



#### Paging과 Sementation 차이

- paging은 고정 크기를 가짐
- segmentation은 가변 크기를 가짐
- paging은 내부 단편화 발생 가능, segmentation은 외부 단편화 발생 가능



#### Paging과 Segmentation 사용 목적

- 메모리 단편화를 해결하기 위함
- 다중 프로그래밍 시스템에서 여러 프로세스를 수용하기 위해 주기억장치를 동적 분할하는 메모리 관리 기법이 필요







---

[참고 1] : <https://velog.io/@dbswl31024/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%95-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98>

[참고 2] : <https://velog.io/@nnnyeong/OS-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94-%ED%8E%98%EC%9D%B4%EC%A7%95-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98>


