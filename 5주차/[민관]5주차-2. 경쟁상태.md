## 경쟁상태(Race Condition)이란?

- 두개 이상의 스레드 혹은 프로세스가 공유자원을 병행적으로 읽거나 쓰는 상황
- Storage(Memory Address Space)를 공유하는 Execution(CPU Process)이 여러개가 있는 경우 경쟁 상태의 가능 성 있음
  - 멀티 프로세서 시스템
  - 여러 프로세스에서 동시에 공유 메모리의 데이터 사용하는 경우



### 경쟁상태가 발생하는 경우

1. 커널 코드 수행 중 인터럽트 발생

![3](https://user-images.githubusercontent.com/44665707/150239544-26275cd1-072b-443d-b554-e536eb3d2fcc.PNG)

- 커널 코드가 수행중인 상황에서 Count++ 를 위해 [1. load]를 진행하여 레지스터 변수에 저장
- 인터럽트가 발생하여 인터럽트 핸들러 통해 처리, Count-- 를 수행
- 1 감소된 Count 값이 다시 1 증가되길 원했지만, 인터럽트 이전에 레지스터에 저장한 값을 로드하여 [2. Inc]가 이어서 실행

해결법 : 커널 코드 수행중에는 인터럽트 처리 루틴을 수행하지 않고 작업이 끝난 후에 처리하도록 하기



2. 프로세스의 시스템 콜로 인해 커널 모드로 수행 중 Context Switching 발생

![4](https://user-images.githubusercontent.com/44665707/150239791-5bc2332f-b9a4-47a7-a27c-e95a08e5fa56.PNG)

- P(A)가 User모드로 수행중에 시스템 콜 요청 -> 커널 모드 진입, 커널 코드 상에서 Count++ 수행 중
- 커널 모드 수행중 최대 CPU시간(Time Quantum) 만료로 인해 Context Switching 발생 -> P(B)
- P(B)에서도 시스템 콜 통해 커널모드 진입 후 동일한 커털 데이터에 대해 Count++ 수행
- P(B)의 최대 CPU시간 만료 후 P(A) 이전 작업 이어 수행 -> P(B)에서 증가시긴 Count 값을 또 증가

해결법 : 커널 모드 수행중에는 프로세스에게서 CPU를 선점해서 빼앗지 않도록 함.  커널 모드 종료 후 해당 프로세스가 유저 모드로 돌아갔을 때 빼앗고 진행



3. 멀티 프로세서 환경 내 공유 메모리 동시 접근

![5](https://user-images.githubusercontent.com/44665707/150240084-ee934366-0b84-4fc9-97ef-30cd097ad04a.PNG)

- 멀티 프로세서 환경에서는 공유되는 메모리에 다른 커널들이 동시에 특정 값에 접근 가능

해결법 : 커널 내부에 있는 각 공유 데이터에 접근할 때마다 lock/unlock 통해 다른 커널의 해당 데이터 접근을 막기, 커널에 접근하는 CPU를 매 순간 하나만 접근할 수 있도록 하기